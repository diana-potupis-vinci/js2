---
title: "HMI & JWT"
description: "Authentification & utilisation d'op√©rations prot√©g√©es par JWT au sein d'une IHM"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part4"> Partie 4 </PathViewerItem>
    <PathViewerItem selected> b) HMI & JWT </PathViewerItem>
</PathViewer>

# b) Authentification & utilisation d'op√©rations prot√©g√©es par JWT au sein d'une IHM

<InternalPageMenu>
  <InternalPageMenuItem> Authentification d'un utilisateur via une IHM & JWT </InternalPageMenuItem>
  <InternalPageMenuItem> Autorisation de l'appel √† une op√©ration prot√©g√©e </InternalPageMenuItem>
  <InternalPageMenuItem> Probl√®mes de s√©curit√© </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 4.2 : Authentification & autorisation au sein de myMovies </InternalPageMenuItem> 
</InternalPageMenu>

# <InternalPageTitle> Authentification d'un utilisateur via une IHM & JWT </InternalPageTitle>

Pour authentifier un utilisateur via une IHM, il suffit de faire une requ√™te √† une RESTful API.

G√©n√©ralement, l'utilisateur devra d'abord cr√©er son compte. Il utilisera un formulaire demandant au minimum un identifiant (username, adresse e-mail ou autres) et un password.  
Dans le cadre d'une SPA, l'IHM fera appel √† une op√©ration de type **register** lorsque l'utilisateur soumet le formulaire.

Par la suite, lorsque le compte de l'utilisateur existe, l'IHM fera appel √† une op√©ration de type **login** lorsque l'utilisateur tentera de se connecter √† l'aide d'un formulaire.

Dans les deux cas, **register** ou **login**, le d√©veloppeur devra conna√Ætre les op√©rations mises √† disposition par l'API. 

Dans le cadre du site de la pizzeria, nous savons que l'API met √† disposition ces deux op√©rations :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **auths/login** | POST | V√©rifier les credentials d'une ressource de type "users" et renvoyer le username et un token JWT si les credentials sont OK |
| **auths/register** | POST | Cr√©er une ressource de type "users" et renvoyer le username et un token JWT |

<br/>

Veuillez d√©marrer la derni√®re version de la RESTful API de la pizzeria. En cas de souci, vous pouvez utiliser ce code-ci :
[auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths).

Nous allons maintenant continuer le d√©veloppement de l'IHM [async-await](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/async-await) pour que le formulaire de register et de login fassent appelle √† l'API et sauve temporairement le token renvoy√©.

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/hmi/jwt-fetch** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/hmi/async-await** (ou [async-await](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/hmi/jwt-fetch**.

Veuillez mettre √† jour le code de la **RegisterPage** afin de faire appel √† la m√©thode **POST /auths/register** et, si tout est OK, renvoyer l'utilisateur vers la **HomePage** via la fonction **Navigate** :
```js numbered highlighting="2,34-63"
import { clearPage, renderPageTitle } from '../../utils/render';
import Navigate from '../Router/Navigate';

const RegisterPage = () => {
  clearPage();
  renderPageTitle('Register');
  renderRegisterForm();
};

function renderRegisterForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const username = document.createElement('input');
  username.type = 'text';
  username.id = 'username';
  username.placeholder = 'username';
  username.required = true;
  username.className = 'form-control mb-3';
  const password = document.createElement('input');
  password.type = 'password';
  password.id = 'password';
  password.required = true;
  password.placeholder = 'password';
  password.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Register';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(username);
  form.appendChild(password);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onRegister);
}

async function onRegister(e) {
  e.preventDefault();

  const username = document.querySelector('#username').value;
  const password = document.querySelector('#password').value;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const response = await fetch('/api/auths/register', options);

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const authenticatedUser = await response.json();

  console.log('Newly registered & authenticated user : ', authenticatedUser);

  Navigate('/');
}

export default RegisterPage;

```

Veuillez ex√©cuter le frontend et vous assurer que l'utilisateur que vous tentez de cr√©er est bien cr√©√© par votre API. Si tout fonctionne, vous aurez une confirmation dans la console de votre browser.

Bien, nous souhaitons pour l'instant sauvegarder **authenticatedUser** de mani√®re temporaire, car cet objet contient comme info le username et le token de l'utilisateur.

üí≠ Comment faire pour que cet objet soit disponible dans d'autres modules ?
Cette question nous permet d'explorer un propri√©t√© importante des **export** d'objets via ECMAScript : ce sont des objets immuables, c'est-√†-dire dont vous ne pouvez pas directement changer leurs valeurs. Comment faire alors pour offrir **authenticatedUser** ?  
Nous allons offrir quatre nouvelles fonctions : 
- une fonction qui renverra l'√©tat d'une variable **authenticatedUser** ;
- une fonction qui permettra de modifier la variable **authenticatedUser** ;
- une fonction qui indiquera si l'utilisateur est authentifi√© ou pas ;
- une fonction qui permettra de faire un reset de l'utilisateur en cours (on utilisera cette fonction lors d'un logout).

Veuillez cr√©er le fichier **/src/utils/auths.js** et y ajouter le code suivant :
```js numbered
let currentUser;

const getAuthenticatedUser = () => currentUser;

const setAuthenticatedUser = (authenticatedUser) => {
  currentUser = authenticatedUser;
};

const isAuthenticated = () => currentUser !== undefined;

const clearAuthenticatedUser = () => {
  currentUser = undefined;
};

// eslint-disable-next-line object-curly-newline
export { getAuthenticatedUser, setAuthenticatedUser, isAuthenticated, clearAuthenticatedUser };
```

Veuillez mettre √† jour le code de la **RegisterPage** afin de sauver en m√©moire vive l'utilisateur authentifi√©. Nous allons aussi pr√©parer la suite afin d'avoir une Navbar qui s'adaptera lorsqu'un utilisateur est authentifi√©, c'est pourquoi nous allons appeler le composant **Navbar** :
```js numbered highlighting="1,3,66,68"
import { setAuthenticatedUser } from '../../utils/auths';
import { clearPage, renderPageTitle } from '../../utils/render';
import Navbar from '../Navbar/Navbar';
import Navigate from '../Router/Navigate';

const RegisterPage = () => {
  clearPage();
  renderPageTitle('Register');
  renderRegisterForm();
};

function renderRegisterForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const username = document.createElement('input');
  username.type = 'text';
  username.id = 'username';
  username.placeholder = 'username';
  username.required = true;
  username.className = 'form-control mb-3';
  const password = document.createElement('input');
  password.type = 'password';
  password.id = 'password';
  password.required = true;
  password.placeholder = 'password';
  password.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Register';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(username);
  form.appendChild(password);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onRegister);
}

async function onRegister(e) {
  e.preventDefault();

  const username = document.querySelector('#username').value;
  const password = document.querySelector('#password').value;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const response = await fetch('/api/auths/register', options);

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const authenticatedUser = await response.json();

  console.log('Newly registered & authenticated user : ', authenticatedUser);

  setAuthenticatedUser(authenticatedUser);

  Navbar();

  Navigate('/');
}

export default RegisterPage;
```

Pour la **LoginPage**, les modifications √† faire sont les m√™mes :
```js numbered highlighting="1,3-4,36-69"
import { setAuthenticatedUser } from '../../utils/auths';
import { clearPage, renderPageTitle } from '../../utils/render';
import Navbar from '../Navbar/Navbar';
import Navigate from '../Router/Navigate';

const LoginPage = () => {
  clearPage();
  renderPageTitle('Login');
  renderRegisterForm();
};

function renderRegisterForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const username = document.createElement('input');
  username.type = 'text';
  username.id = 'username';
  username.placeholder = 'username';
  username.required = true;
  username.className = 'form-control mb-3';
  const password = document.createElement('input');
  password.type = 'password';
  password.id = 'password';
  password.required = true;
  password.placeholder = 'password';
  password.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Login';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(username);
  form.appendChild(password);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onLogin);
}

async function onLogin(e) {
  e.preventDefault();

  const username = document.querySelector('#username').value;
  const password = document.querySelector('#password').value;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const response = await fetch('/api/auths/login', options);

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const authenticatedUser = await response.json();

  console.log('Authenticated user : ', authenticatedUser);

  setAuthenticatedUser(authenticatedUser);

  Navbar();

  Navigate('/');
}

export default LoginPage;
```

Nous souhaitons maintenant faire en sorte que la Navbar affiche des √©l√©ments diff√©rents si l'utilisateur est authentifi√© au pas :
- s'il est authentifi√© : on affiche **Home**, **Login**, **Register** et le **username** de l'utilisateur connect√©.
- s'il est anonyme : on affiche **Home**, **Add a pizza**, **Logout**.

Nous allons mettre √† jour la **Navbar** pour s'adapter √† l'authentification d'un utilisateur :
```js
// eslint-disable-next-line no-unused-vars
import { Navbar as BootstrapNavbar } from 'bootstrap';
import { getAuthenticatedUser, isAuthenticated } from '../../utils/auths';

const Navbar = () => {
  renderNavbar();
};

function renderNavbar() {
  const authenticatedUser = getAuthenticatedUser();

  const anonymousUserNavbar = `
<nav class="navbar navbar-expand-lg navbar-light bg-danger">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">e-Pizzeria</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#" data-uri="/">Home</a>
            </li>
            <li id="loginItem" class="nav-item">
              <a class="nav-link" href="#" data-uri="/login">Login</a>
            </li>
            <li id="registerItem" class="nav-item">
              <a class="nav-link" href="#" data-uri="/register">Register</a>
            </li>            
          </ul>
        </div>
      </div>
    </nav>
`;

  const authenticatedUserNavbar = `
<nav class="navbar navbar-expand-lg navbar-light bg-danger">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">e-Pizzeria</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#" data-uri="/">Home</a>
            </li>          
            <li class="nav-item">
              <a class="nav-link" href="#" data-uri="/add-pizza">Add a pizza</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" data-uri="/logout">Logout</a>
            </li>    
            <li class="nav-item">
              <a class="nav-link disabled" href="#">${authenticatedUser?.username}</a>
            </li>           
          </ul>
        </div>
      </div>
    </nav>
`;

  const navbar = document.querySelector('#navbarWrapper');

  navbar.innerHTML = isAuthenticated() ? authenticatedUserNavbar : anonymousUserNavbar;
}

export default Navbar;
```

Ce code est quasi enti√®rement neuf. On a rajout√© l'√©l√©ment qui permettra de r√©aliser le logout d'un utilisateur. Avant d'aller plus loin, veuillez tester l'application.  
Loguez-vous avec l'utilisateur **admin** (et le password **admin**) et v√©rifier que vous √™tes bien redirig√© vers la HomePage une fois authentifi√©, que la Navbar contient bien les √©l√©ments attendus, dont le **username**.  
Veuillez maintenant tester un clic sur l'√©l√©ment **Add a pizza** de la Navbar. Il ne se passe rien...  
üí≠ Pourquoi les clics ne sont plus pris en compte ?  
En fait, regardons le code de notre **Router**, pour la gestion des clics sur la **Navbar** :
```js
function onNavBarClick() {
  const navItems = document.querySelectorAll('.nav-link');

  navItems.forEach((item) => {
    item.addEventListener('click', (e) => {
      e.preventDefault();
      const uri = e.target?.dataset?.uri;
      const componentToRender = routes[uri];
      if (!componentToRender) throw Error(`The ${uri} ressource does not exist.`);

      componentToRender();
      window.history.pushState({}, '', uri);
    });
  });
}
```

En fait, tant dans **LoginPage** que dans **RegisterPage**, nous faisons appel √† la fonction **`Navbar`** qui fait un "rerender" (r√©affichage) de la Navbar. Ainsi, tous les √©l√©ments de la barre de navigation sont "rerender", et donc comme le **Router** n'est pas r√©appel√©, la fonction **`onNavBarClick`** n'est pas r√©ex√©cut√©e. Ainsi, m√™me si les nouveaux √©l√©ments de la Navbar ont la classe CSS **`nav-link`**, leurs √©couteurs d'√©v√©nements de type click n'existent pas.

üí≠ Comment corriger cela ?
On pourrait se dire qu'il suffit de faire appel √† la fonction **`onNavBarClick`** dans la **Navbar**. Cette solution ne fonctionnerait pas car nous aurions des d√©pendances cycliques, la Navbar devrait faire appel aux routes, qui elles font appel aux pages, les pages faisant appel √† la Navbar...  
D√®s lors, le mieux serait de mettre un √©couteur d'√©v√©nements au niveau du wrapper de la Navbar.  
Comme le wrapper n'est jamais r√©initialis√©, tout sera en ordre.  
Veuillez donc mettre √† jour la fonction **`onNavBarClick`** de **/src/Components/Router/Router.js** :
```js highlighting="2,4,6-8"
function onNavBarClick() {
  const navbarWrapper = document.querySelector('#navbarWrapper');

  navbarWrapper.addEventListener('click', (e) => {
    e.preventDefault();
    const navBarItemClicked = e.target;
    const uri = navBarItemClicked?.dataset?.uri;
    if (uri) {
      const componentToRender = routes[uri];
      if (!componentToRender) throw Error(`The ${uri} ressource does not exist.`);

      componentToRender();
      window.history.pushState({}, '', uri);
    }
  });
}
```

Veuillez noter que le **navbarWrapper** est initialis√© au sein du composant **Header**.  
Dans la nouvelle version du code du **Router**, le gestionnaire de clic est ajout√© au niveau de ce wrapper. Gr√¢ce √† l'event objet **`e`**, on acc√®de √† l'√©l√©ment sur lequel on a cliqu√© gr√¢ce √† la propri√©t√© **`target`**. On retrouve donc l'√©l√©ment de la navbar sur lequel on a cliqu√© tr√®s facilement. 

Veuillez tester votre IHM et v√©rifier qu'une fois logu√©, vous puissiez bien voyager entre les pages.

Il reste maintenant √† cr√©er un composant permettant de faire un logout. On souhaite que ce composant de logout supprime l'utilisateur authentifi√©, r√©affiche la Navbar pour un utilisateur anonyme et redirige l'utilisateur vers la page de login.

Pour ce faire, veuillez cr√©er le dossier et le fichier **/src/Components/Logout/Logout.js** et y ajouter ce code :
```js
import { clearAuthenticatedUser } from '../../utils/auths';
import Navbar from '../Navbar/Navbar';
import Navigate from '../Router/Navigate';

const Logout = () => {
  clearAuthenticatedUser();
  Navbar();
  Navigate('/login');
};

export default Logout;
```

Attention, m√™me si nous avons mis √† jour la **Navbar** et cr√©√© le composant **Logout**, le boilerplate du frontend impose de rajouter une route au sein du **Router** pour qu'un clic sur l'√©l√©ment **Logout** de la **Navbar** am√®ne √† appeler le composant **Logout**.
Veuillez donc mettre √† jour **`routes`** au sein de **/src/Components/Router/Router.js** :
```js highlighting="1,12"
import Logout from '../Logout/Logout';
import AddPizzaPage from '../Pages/AddPizzaPage';
import HomePage from '../Pages/HomePage';
import LoginPage from '../Pages/LoginPage';
import RegisterPage from '../Pages/RegisterPage';

const routes = {
  '/': HomePage,
  '/login': LoginPage,
  '/register': RegisterPage,
  '/add-pizza': AddPizzaPage,
  '/logout': Logout,
};
```

Veuillez maintenant tester le login et le logout. Tout devrait √™tre fonctionnel !  
Il nous reste √† faire en sorte que l'on puisse autoriser l'op√©ration de cr√©ation de pizza.

# <InternalPageTitle> Autorisation de l'appel √† une op√©ration prot√©g√©e  </InternalPageTitle>

Nous allons maintenant voir comment, √† partir d'une IHM, nous pouvons utiliser un token pour acc√©der √† une op√©ration d'une RESTful API.

Veuillez vous assurer que la derni√®re version de la RESTful API de la pizzeria est bien d√©marr√©e. En cas de souci, vous pouvez utiliser ce code-ci :
[auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths).

Veuillez vous connecter √† l'IHM **jwt-fetch** √† l'aide du compte **manager** et tentez d'ajouter une pizza. Cela ne devrait pas fonctionner. Veuillez regarder dans la console : il devrait y avoir une erreur qui s'affiche avec le "status code" **401 : Unauthorized**.  
En effet, l'API attend un token pour autoriser l'op√©ration de cr√©ation d'une pizza.

Nous allons donc mettre √† jour **/src/Components/Pages/AddPizzaPage.js** pour ajouter le token de l'utilisateur authentifi√© au sein du header de la requ√™te (il n'y a que trois lignes √† rajouter) :
```js numbered highlighting="1,44,54"
import { getAuthenticatedUser } from '../../utils/auths';
import { clearPage, renderPageTitle } from '../../utils/render';
import Navigate from '../Router/Navigate';

const AddPizzaPage = () => {
  clearPage();
  renderPageTitle('Add a pizza to the menu');
  renderAddPizzaForm();
};

function renderAddPizzaForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const title = document.createElement('input');
  title.type = 'text';
  title.id = 'title';
  title.placeholder = 'title of your pizza';
  title.required = true;
  title.className = 'form-control mb-3';
  const content = document.createElement('input');
  content.type = 'text';
  content.id = 'content';
  content.required = true;
  content.placeholder = 'Content of your pizza';
  content.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Add pizza to the menu';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(title);
  form.appendChild(content);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onAddPizza);
}

async function onAddPizza(e) {
  e.preventDefault();

  const title = document.querySelector('#title').value;
  const content = document.querySelector('#content').value;

  const authenticatedUser = getAuthenticatedUser();

  const options = {
    method: 'POST',
    body: JSON.stringify({
      title,
      content,
    }),
    headers: {
      'Content-Type': 'application/json',
      Authorization: authenticatedUser.token,
    },
  };

  const response = await fetch('/api/pizzas', options);

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const newPizza = await response.json();

  console.log('New pizza added : ', newPizza);

  Navigate('/');
}

export default AddPizzaPage;

```

Veuillez vous connecter √† l'IHM √† l'aide du compte **manager** et tentez d'ajouter une pizza. Cela ne devrait toujours pas fonctionner. Veuillez regarder dans la console : il devrait y avoir une erreur qui s'affiche avec le "status code" **403 : Forbidden**.  
En effet, l'API attend un token pour autoriser l'op√©ration de cr√©ation d'une pizza, mais seulement **admin** a le privil√®ge d'ajouter une pizza au menu !

D√©connectez-vous (logout), reconnectez-vous √† l'aide du compte **admin**, et ajoutez une pizza.
Voila ! Le site devrait √™tre enti√®rement fonctionnel !

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**jwt-fetch**".

En cas de souci, vous pouvez utiliser le code du tutoriel :

- pour le frontend : [jwt-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch).
- pour l'API : [auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths).

üí≠ Est-ce que c'est "safe" que notre IHM affiche le menu "Add a pizza" pour un utilisateur qui n'est pas l'admin ?  
En fait oui, c'est "safe", vous l'avez test√©. L'API ne doit jamais faire confiance aux applications clientes pour appliquer la s√©curit√©. Ainsi, m√™me si le frontend autorise l'acc√®s √† des op√©rations qui ne devraient pas √™tre permises, au regard des autorisations appliqu√©es par l'API, √ßa n'a pas d'importance point de vue s√©curit√©.  
De la m√™me fa√ßon, c'est pour √ßa qu'une API doit aussi toujours valider les param√®tres qu'elle re√ßoit. Elle ne peut pas faire confiance aux applications clientes, comme par exemple √† une application web tournant dans un browser, pour valider tous les champs d'un formulaire avant de faire la requ√™te.  
La raison est simple, l'API est d√©velopp√©e ind√©pendamment des applications clientes, elle ne peut pas supposer que les requ√™tes seront toujours bien construites.

üí≠ OK, tout est "safe" si l'API fait toutes les v√©rifications n√©cessaires. N√©anmoins, n'y a-t-il pas des r√®gles de bonnes pratiques au niveau des IHM, pour ne pas permettre de faire n'importe quelles requ√™tes vers des API ?  
Et bien oui, au niveau des IHM, pour des questions d'**ergonomie**, d'exp√©rience utilisateur, on va faire en sorte :
- de ne pas offrir des op√©rations qui ne seront pas autoris√©es. Par exemple, dans le cadre de ce tutoriel sur un site permettant de g√©rer une pizzeria, si l'utilisateur n'est pas **admin**, alors il ne faut pas frustrer les utilisateurs en leur faisant croire qu'ils ont acc√®s √† l'op√©ration de cr√©er une pizza ! Imaginez-vous, vous cr√©er une nouvelle pizza de 32 ingr√©dients, et lors de la soumission, vous recevez un message comme quoi vous n'√™tes pas l'admin du site et que vous n'avez donc pas le droit de cr√©er une pizza üò≤!
- de ne pas demander du travail √† une API quand l'IHM peut d√©tecter que ce n'est pas utile. 
Ainsi, quand une IHM offre des formulaires, qui am√®neront √† des requ√™tes vers des API, on √©vitera d'autoriser la soumission des donn√©es tant que les champs n'ont pas √©t√© valid√©s. Tout ce que l'IHM peut valider c√¥t√© client, elle doit le faire. Le feedback sera plus rapide pour l'utilisateur, et les ressources de l'API seront √©conomis√©es (pas d'appel inutile).

N'h√©sitez donc pas √† mettre √† jour ce tutoriel pour faire en sorte de n'afficher "Add a pizza" que si l'utilisateur est **admin**.

üí≠ Ca n'est pas un peu "cheap" que seul l'utilisateur **admin** puisse avoir le privil√®ge d'administrateur du site ?  
H√© bien oui, c'est "cheap". G√©n√©ralement, dans le cadre d'applications plus robustes, nous allons ajouter un ou plusieurs r√¥les aux utilisateurs. Par exemple, dans le cadre d'applications o√π les r√¥les sont simples, qu'il n'y a jamais qu'un seul r√¥le associ√© √† un utilisateur, il suffirait d'ajouter au niveau de l'API la propri√©t√© **role** aux utilisateurs. Par exemple, la majorit√© des utilisateurs pourrait avoir un r√¥le dont la valeur serait **default**, et une minorit√© d'utilisateur auraient le r√¥le d'**admin**...

On n'affiche actuellement **pas de message d'erreur** √† l'utilisateur lorsque la r√©ponse d'une API renvoie une erreur. Pour am√©liorer l'exp√©rience de l'utilisateur, ce serait une am√©lioration √† faire.

Finalement, lorsqu'on ferme le browser et revient sur l'application par la suite, on n'est plus authentifi√©. Nous allons donc prochainement voir comment nous pourrions sauvegarder des donn√©es de session c√¥t√©-client, dans le browser.

# <InternalPageTitle> Probl√®mes de s√©curit√©  </InternalPageTitle>

Il y a un probl√®me de s√©curit√© majeur actuellement. Nous pourrions √™tre victime d'attaques de type XSS : des injections de JS malicieux sont possibles üò® !  
De plus, si quelqu'un a acc√®s au fichier **/data/users.json** pr√©sent sur l'API, il a acc√®s √† tous les passwords des utilisateurs en clair üò® !

Nous allons r√©aliser un exercice avant de traiter des probl√®mes de s√©curit√©.

# <InternalPageTitle> Exercice 4.2 : Authentification & autorisation au sein de myMovies </InternalPageTitle>

Lors de l'exercice pr√©c√©dent (Exercice 6.2), vous aviez une application qui permettait normalement de g√©rer des films, mais qui n'√©tait pas s√©curis√©e.

A cet exercice, veuillez introduire l'authentification d'utilisateur via ces deux nouveaux cas d'utilisation :
- UC5 : un utilisateur doit pouvoir cr√©er un compte (register).
- UC6 : un utilisateur doit pouvoir se loguer (login).
- UC7 : un utilisateur doit pouvoir se d√©connecter (logout).

Vous allez continuer le d√©veloppement du frontend de **myMovies** r√©alis√© au module 3 (Exercice 3.1) et de la RESTful API d√©velopp√©e au module 5 (Exercice 5.2).

L'application **myMovies** doit maintenant autoriser les op√©rations suivantes aux utilisateurs authentifi√©s uniquement :
-	UC2 : l'ajout d'une ressource de type films via un formulaire d'ajout d'un film.
- UC3 : la suppression d'un film.
- UC4 : la mise √† jour des donn√©es d'un film (√† l'exception de l'id associ√© √† un film).

Comme auparavant, cette op√©ration est permise pour tous les utilisateurs, anonymes ou authentifi√©s :
-	UC1 : l'affichage, sous forme de tableau, de toutes les ressources de type films.

Vous allez devoir mettre √† jour tant l'API que le frontend.

Voici les op√©rations qui doivent √™tre mises √† disposition par votre API :

##### Op√©rations sur les ressources de type "auths"
| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **auths/register** | POST | Non | Cr√©er une ressource de type "users" et renvoyer le username et un token JWT |
| **auths/login** | POST | Non | V√©rifier les credentials d'une ressource de type "users" et renvoyer le username et un token JWT si les credentials sont OK |

<br/>

##### Op√©rations sur les ressources de type "films" (ou "movies", selon votre choix)
| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **films** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| **films?minimum-duration=value** | GET | Non | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`films/{id}`** | GET | Non | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | JWT | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **`films/{id}`** | DELETE | JWT | DELETE ONE : Effacer la ressource identifi√©e |
| **`films/{id}`** | PATCH | JWT | UPDATE ONE : Mettre √† jour les propri√©t√©s de la ressource par les valeurs donn√©es dans la requ√™te, pour une ou plusieurs propri√©t√©s |

<br/>

Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :
-	Commencez par mettre √† jour l'API pour ajouter les op√©rations de register, de login, ainsi que les autorisations pour les fonctions d'√©critures sur des ressources de type films. Utilisez le contenu de votre r√©pertoire d'exercices **/exercises/module5/5.2** comme point de d√©part pour cr√©er, dans votre repository local et votre web repository (normalement appel√© **web2**), le r√©pertoire nomm√© **/exercises/module7/7.1/api**.
- Veuillez tester votre API via REST Client pour vous assurer que les autorisations JWT fonctionnent correctement. Quand tout est OK, vous pouvez passer au d√©veloppement de votre frontend.
-	Pour le frontend, utilisez le contenu de votre r√©pertoire d'exercices **/exercises/module6/6.2** comme point de d√©part pour cr√©er, dans votre repository local et
votre web repository (normalement appel√© **web2**), le r√©pertoire nomm√©
**/exercises/module7/7.1/hmi**.
-	Veuillez utiliser le proxy de votre frontend afin de contourner les probl√®mes associ√© √† la gestion des CORS.
- Veuillez d√©velopper de mani√®re incr√©mentale votre IHM, use case par use case, en v√©rifiant le bon fonctionnement de chaque cas d'utilisation avant de passer au d√©veloppement de l'UC suivant.  
Nous vous recommandons de commencer par le m√©canisme d'authentification en ajoutant l'UC5 et l'UC6. Notez qu'il est facile de d√©marrer avec l'UC6 pour le login d'admin qui existe d√©j√† au niveau de l'API par d√©faut.
- Pensez √† bien mettre √† jour votre **Navbar** pour afficher les bons menus :
  - si l'utilisateur est anonyme : liens uniquement vers la HomePage, vers l'UC1 (view movies), UC5 (login) & UC6 (register) ;
  - si l'utilisateur est authentifi√© : liens uniquement vers la HomePage, vers l'UC1 (view movies) / UC2 (create) / UC3 (delete) / UC4 (update), UC7 (logout).
- Faites attention, il n'est pas autoris√©, pour des raisons d'ergonomie, que le frontend offre les fonctionnalit√©s d'√©criture de ressources si l'utilisateur n'est pas authentifi√© : UC2 (create), UC3 (delete) et UC4 (update) sont des op√©rations invisibles pour un utilisateur anonyme.

#### ü§ù Tips
- Cet exercice est l'application du tutoriel vu dans ce module-ci. N'h√©sitez pas donc √† rejouer les √©tapes vues dans le tutoriel au niveau de votre API et √† copier / coller les fichiers utiles (**authorize.js**, **users.js**, **auths.js**...) : [a) Authentification s√©curis√©e et autorisation d'acc√®s aux op√©rations d'une RESTful API via JWT](#a).
- N'oubliez pas de tester chaque op√©ration. Par exemple, il faut bien v√©rifier que l'on ne puisse pas cr√©er une pizza sans token via REST Client.
- Occupez-vous ensuite du frontend en copiant collant les fichiers utiles trouv√©s dans le tutoriel associ√© √† cette partie (**RegisterPage**, **LoginPage**, **Logout**, **auths**, **Navbar**...) : [b) Utilisation de JWT au sein d'une IHM](#b).  
Attention √† ne pas oublier de mettre √† jour votre Router (nouvelles pages pour le register, le login et le logout), la Navbar (diff√©rent affichage pour un utilisateur anonyme que pour un utilisateur connect√©), d'ajouter les token dans le header de vos requ√™tes via fetch... 
- Concernant le Router, il faut mettre √† jour `onNavBarClick` pour que les gestionnaires d'ev√©n√©ments restent attach√©s m√™me quand la Navbar est r√©affich√©e.
- üí≠ Comment rendre invisible les op√©rations d'√©criture de films ?  
Par exemple, vous pourriez afficher les boutons **Delete** et **Save** que si l'utilisateur est authentifi√©.  
De m√™me, si l'utilisateur est anonyme, les cellules associ√©es aux films ne devraient pas √™tre √©ditables.

Veuillez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 7 : auths**"".

NB : Le code de vos applications se trouve dans votre repository local et
votre web repository (normalement appel√© **web2**) dans les r√©pertoires nomm√©s
**/exercises/module7/7.1/api** et **/exercises/module7/7.1/hmi**.