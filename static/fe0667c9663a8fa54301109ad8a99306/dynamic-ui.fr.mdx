---
title: "UI dynmamique"
description: "Cr√©ation dynamique de UI"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> e) Cr√©ation dynamique de UI </PathViewerItem>
</PathViewer>

# e) Cr√©ation dynamique de UI

<InternalPageMenu>
  <InternalPageMenuItem> Pourquoi g√©n√©rer dynamiquement une UI ? </InternalPageMenuItem>
  <InternalPageMenuItem> G√©n√©ration d'HTML √† partir d'une string </InternalPageMenuItem>
  <InternalPageMenuItem> Ajout dynamique d'√©couteurs d'√©v√©nements une fois le DOM rendu </InternalPageMenuItem>
  <InternalPageMenuItem> G√©n√©ration d'HTML √† partir de Nodes </InternalPageMenuItem>
  <InternalPageMenuItem> Ajout dynamique d'√©couteurs d'√©v√©nements avant de rendre le DOM </InternalPageMenuItem>
  <InternalPageMenuItem> Ajout dynamique d'images ou d'autres assets </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.6 : G√©n√©ration dynamique de la Homepage de myMovies </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.7 : G√©n√©ration dynamique d'une table sur base d'un formulaire </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.8 : design responsive </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Pourquoi g√©n√©rer dynamiquement une UI ? </InternalPageTitle>

Nous souhaitons parfois g√©n√©rer des parties d'IHM dynamiquement, √† l'aide de JS.

Nous pourrions souhaiter g√©n√©rer de l'HMTL dynamiquement pour plusieurs raisons. Par exemple, si nous souhaitions afficher diff√©rentes pages sans faire appel au serveur.
Lors d'un clic sur un √©l√©ment d'une Navbar, nous pourrions g√©n√©rer dynamiquement l'HTML de la page associ√©e √† cet √©l√©ment.

Un autre exemple serait l'affichage d'un tableau HTML suite √† la r√©ception de donn√©es envoy√©es par un web service.

Il existe principalement deux fa√ßon de g√©n√©rer des √©l√©ments HTML, soit √† partir de String, soit √† partir de "Nodes" (ou HTML elements).

# <InternalPageTitle> G√©n√©ration d'HTML √† partir d'une string </InternalPageTitle>

Nous pouvons utiliser la propri√©t√© **innerHTML** d'un √©l√©ment existant pour cr√©er de l'HTML √† l'aide d'une String.

Lorsque nous allons ajouter une String √† la propri√©t√© **innerHTML** d'un √©l√©ment, le browser va s'occuper de cr√©er des "Node elements" et les attacher au "DOM tree" au sein de l'√©l√©ment que nous modifions. 

Nous souhaitons ajouter un menu √† notre site de la pizzeria √† g√©n√©rer √† partir d'un array.

Voici le nouveau code √† ajouter pour g√©n√©rer ce menu au sein de **/src/index.js** : 


```js numbered highlighting="5-31,37,46-86"
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

const body = document.querySelector('body');

body.addEventListener('click', startOrStopSound);

renderMenuFromString(MENU);

function startOrStopSound() {
  const myAudioPlayer = document.querySelector('#audioPlayer');

  if (myAudioPlayer.paused) myAudioPlayer.play();
  else myAudioPlayer.pause();
}

function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  main.innerHTML += menuTableAsString;
}

function getMenuTableAsString(menu) {
  const menuTableLines = getAllTableLinesAsString(menu);
  const menuTable = addLinesToTableHeadersAndGet(menuTableLines);
  return menuTable;
}

function addLinesToTableHeadersAndGet(tableLines) {
  const menuTable = `
  <div class="table-responsive pt-5">
    <table class="table table-danger">
      <tr>
        <th>Pizza</th>
        <th>Description</th>
      </tr>
      ${tableLines}    
    </table>
  </div>
  `;
  return menuTable;
}

function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}
```

Dans un premier temps, nous avons acc√©der √† l'√©l√©ment **main** en tant qu'HTML element (ou Node).

Nous avons ensuite g√©n√©r√© une String multilignes √† l'aide des `template literals` pour repr√©senter le menu, pour finalement ajouter au **main** de nouveaux √©l√©ments en concat√©nant cette String √† sa propri√©t√© **innerHTML**. 

# <InternalPageTitle> Ajout dynamique d'√©couteurs d'√©v√©nements une fois le DOM rendu </InternalPageTitle>

A ce stade-ci, nous souhaiterions ajouter un gestionnaire de passage de souris sur le menu.  
Au passage sur le menu, nous souhaitons changer la couleur du background afin que le menu devienne vert. Lorsqu'on quitte le menu, celle-ci doit reprendre sa couleur initiale.

Voici le code mis √† jour de **index.js** :

```js numbered highlighting="39,90-99"
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

const body = document.querySelector('body');

body.addEventListener('click', startOrStopSound);

renderMenuFromString(MENU);

attachOnMouseEventsToGoGreen();

function startOrStopSound() {
  const myAudioPlayer = document.querySelector('#audioPlayer');

  if (myAudioPlayer.paused) myAudioPlayer.play();
  else myAudioPlayer.pause();
}

function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  main.innerHTML += menuTableAsString;
}

function getMenuTableAsString(menu) {
  const menuTableLines = getAllTableLinesAsString(menu);
  const menuTable = addLinesToTableHeadersAndGet(menuTableLines);
  return menuTable;
}

function addLinesToTableHeadersAndGet(tableLines) {
  const menuTable = `
  <div class="table-responsive pt-5">
    <table class="table table-danger">
      <tr>
        <th>Pizza</th>
        <th>Description</th>
      </tr>
      ${tableLines}    
    </table>
  </div>
  `;
  return menuTable;
}

function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}

function attachOnMouseEventsToGoGreen() {
  const table = document.querySelector('table');
  table.addEventListener('mouseover', () => {
    table.className = 'table table-success';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-danger';
  });
}
```

Une fois le menu rendu, nous y acc√©dons en obtenant une r√©f√©rence vers le Node repr√©sentant ce menu au sein du DOM tree.

Nous acc√©dons √† l'attribut **class** d'une **table** en modifiant, en JS, l'attribut **className**.  
Il est aussi possible d'affiner la gestion des classes CSS en ajoutant ou supprimant des classes via la propri√©t√© **classList** d'un Node (ou HTML element).

Ici, nous avons utilis√© les classes Bootstrap "table-success" pour mettre en vert, et "table-danger" pour que √ßa soit en rouge.

Il est √† noter ces dangers quand on utilise des Strings pour g√©n√©rer de l'HTML.

## ‚ö° Danger N¬∞1 : oubli de mettre √† jour le DOM avant d'attacher ses √©couteurs

Il arrive tr√®s souvent aux jeunes d√©veloppeurs web de faire une erreur de ce genre.  
Regarder le code d'**index.js** et imaginez que vous attachiez les √©couteurs d'√©v√©nements dans **renderMenuFromString()** et plus apr√®s l'appel de cette fonction :

```js highlighting="6"
function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  attachOnMouseEventsToGoGreen();

  main.innerHTML += menuTableAsString;
}
```

Comme la **table** n'a pas √©t√© rendue dans le DOM, il n'est pas possible d'acc√©der √† celle-ci !  
Une exception serait donc lanc√©e dans la console de votre browser.

Tout cela semble logique, mais pensez-y en cas de souci avec vos √©couteurs d'√©v√©nements üòâ.

## ‚ö° Danger N¬∞2 : mise √† jour du DOM apr√®s avoir ajout√© ses √©couteurs

Il arrive aussi r√©guli√®rement aux jeunes d√©veloppeurs web de faire une erreur de ce style.  
Regardez le code d'**index.js** et imaginez que vous souhaitiez ajouter une l√©gende au menu :

```js highlighting="5-6"
renderMenuFromString(MENU);

attachOnMouseEventsToGoGreen();

const mainWrapper = document.querySelector('main');
mainWrapper.innerHTML += '<figcaption class="text-light text-decoration-underline">Our pizzas</figcaption>';
```

‚ö° L'update du DOM d'un √©l√©ment fait un reset de tous les √©couteurs d'√©v√©nements pr√©c√©demment attach√©s ! Pensez-y en cas de souci avec vos √©couteurs d'√©v√©nements üòâ.  
Dans notre exemple, la gestion des passages de la souris sur le menu des pizzas ne serait plus fonctionnelle.

# <InternalPageTitle> G√©n√©ration d'HTML √† partir de Nodes </InternalPageTitle>

Il est possible de directement cr√©er un Node (ou HTML element) √† l'aide de la m√©thode **`document.createElement()`**.

Une fois un Node cr√©√©, on demande de l'ajouter au "DOM tree" via la m√©thode **`appendChild()`**.

Voici un petit exemple d'ajout d'un titre au **main** :

```js
const mainWrapper = document.querySelector('main');
// Create the child element
const h1 = document.createElement('h1');
// Change its property
h1.innerText = 'Hello World';
// Attach the child element to its parent
mainWrapper.appendChild(h1);
```

Nous souhaitons ajouter un nouveau menu pour les boissons √† notre site de la pizzeria, √† g√©n√©rer √† partir d'un array.

Voici le nouveau code √† ajouter pour g√©n√©rer la liste des boissons au sein de **/src/index.js** : 


```js numbered highlighting="33-49,59,121-159"
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

const DRINKS = [
  {
    id: 1,
    title: 'Lemonade',
    content: 'Sparkling water, lemon, ice cubes',
  },
  {
    id: 2,
    title: 'Ice tea',
    content: 'Mint, ginger, water',
  },
  {
    id: 3,
    title: 'Exotic Kombucha',
    content: 'Mango, Sparkling water, Fermented tea',
  },
];

const body = document.querySelector('body');

body.addEventListener('click', startOrStopSound);

renderMenuFromString(MENU);

attachOnMouseEventsToGoGreen();

renderDrinksFromNodes(DRINKS);

function startOrStopSound() {
  const myAudioPlayer = document.querySelector('#audioPlayer');

  if (myAudioPlayer.paused) myAudioPlayer.play();
  else myAudioPlayer.pause();
}

function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  main.innerHTML += menuTableAsString;
}

function getMenuTableAsString(menu) {
  const menuTableLines = getAllTableLinesAsString(menu);
  const menuTable = addLinesToTableHeadersAndGet(menuTableLines);
  return menuTable;
}

function addLinesToTableHeadersAndGet(tableLines) {
  const menuTable = `
  <div class="table-responsive pt-5">
    <table class="table table-danger">
      <tr>
        <th>Pizza</th>
        <th>Description</th>
      </tr>
      ${tableLines}    
    </table>
  </div>
  `;
  return menuTable;
}

function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}

function attachOnMouseEventsToGoGreen() {
  const table = document.querySelector('table');
  table.addEventListener('mouseover', () => {
    table.className = 'table table-success';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-danger';
  });
}

function renderDrinksFromNodes(drinks) {
  const drinksTableAsNode = getDrinksTableAsNode(drinks);

  const main = document.querySelector('main');

  main.appendChild(drinksTableAsNode);
}

function getDrinksTableAsNode(drinks) {
  const tableWrapper = document.createElement('div');
  tableWrapper.className = 'table-responsive pt-5';
  const table = document.createElement('table');
  const tbody = document.createElement('tbody');
  table.id = 'table-drinks';
  table.className = 'table table-success';
  tableWrapper.appendChild(table);
  table.appendChild(tbody);
  const header = document.createElement('tr');
  const header1 = document.createElement('th');
  header1.innerText = 'Drink';
  const header2 = document.createElement('th');
  header2.innerText = 'Description';
  header.appendChild(header1);
  header.appendChild(header2);
  tbody.appendChild(header);

  drinks?.forEach((drink) => {
    const line = document.createElement('tr');
    const title = document.createElement('td');
    const description = document.createElement('td');
    title.innerText = drink.title;
    description.innerText = drink.content;
    line.appendChild(title);
    line.appendChild(description);
    tbody.appendChild(line);
  });

  return tableWrapper;
}
```

# <InternalPageTitle> Ajout dynamique d'√©couteurs d'√©v√©nements avant de rendre le DOM </InternalPageTitle>

Lorsque l'on vient de cr√©er un Node, il est possible de directement lui attacher un √©couteur d'√©v√©nements.

Nous souhaiterions ajouter un gestionnaire de passage de souris sur la liste des boissons.  
Au passage sur la liste, nous souhaitons changer la couleur du background afin qu'elle devienne rouge. Lorsqu'on quitte la liste, celle-ci doit reprendre sa couleur initiale.

Voici le code que vous devez ajouter √† la m√©thode **getDrinksTableAsNode()** au sein de **index.js** :

```js numbered highlighting="30-36"
function getDrinksTableAsNode(drinks) {
  const tableWrapper = document.createElement('div');
  tableWrapper.className = 'table-responsive pt-5';
  const table = document.createElement('table');
  const tbody = document.createElement('tbody');
  table.id = 'table-drinks';
  table.className = 'table table-success';
  tableWrapper.appendChild(table);
  table.appendChild(tbody);
  const header = document.createElement('tr');
  const header1 = document.createElement('th');
  header1.innerText = 'Drink';
  const header2 = document.createElement('th');
  header2.innerText = 'Description';
  header.appendChild(header1);
  header.appendChild(header2);
  tbody.appendChild(header);

  drinks?.forEach((drink) => {
    const line = document.createElement('tr');
    const title = document.createElement('td');
    const description = document.createElement('td');
    title.innerText = drink.title;
    description.innerText = drink.content;
    line.appendChild(title);
    line.appendChild(description);
    tbody.appendChild(line);
  });

  table.addEventListener('mouseover', () => {
    table.className = 'table table-danger';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-success';
  });

  return tableWrapper;
}
```

Nous avons ajout√© deux √©couteurs d'√©v√©nements √† la **table** en cours de construction.  
Notons que ces √©couteurs peuvent √™tre ajout√©s avant ou apr√®s avoir fait l'ajout de la table dans le "DOM tree", cela ne change rien.

Regardez le code d'**index.js** et imaginez que vous souhaitiez ajouter une l√©gende √† la liste de boissons, en utilisant des Nodes :

```js highlighting="3-7"
renderDrinksFromNodes(DRINKS);

const mainWrapper = document.querySelector('main');
const figcaption = document.createElement('figcaption');
figcaption.innerText = 'Our drinks';
figcaption.className = 'text-light text-decoration-underline';
mainWrapper.appendChild(figcaption);
```

Le fait d'ajouter un Node au "DOM tree" ne fait pas de reset des √©couteurs d'√©v√©nements pr√©c√©demment attach√©s ! C'est un avantage √† g√©n√©rer de l'HTML √† partir de Nodes plut√¥t qu'√† partir d'une string.

N'h√©sitez pas √† tester ce morceau de code pour vous rendre compte que la liste de boissons continue √† bien g√©rer les mouvements de la souris.

# <InternalPageTitle> Ajout dynamique d'images ou d'autres assets  </InternalPageTitle>

Lorsque l'on souhaite ajouter une image ou tout autre assets (son, vid√©o...) via du JS et que l'on utilise un module bundler comme Webpack, on ne peut pas juste ajouter une balise **`<image`** avec le chemin en relatif vers celle-ci.

Pourquoi pas ?  Parce qu'en fait, le bundler va s'occuper de copier, et parfois d'optimiser les assets dans le "build", g√©n√©ralement g√©n√©r√© dans le r√©pertoire **/dist** de votre projet.
Ainsi, lorsque vous d√©veloppez votre code, l'image se trouve √† un endroit diff√©rent d'o√π se trouvera l'image lors du build.

Pour bien g√©rer les URL au sein de votre JS, vous devez d'abord importer vos assets.  
Voici un exemple pour ajouter une image dynamiquement au sein du **`<footer>`** : 

```js
import pizzaImage from './img/pizza2.jpg';

renderPizzaImage(pizzaImage);

function renderPizzaImage(pizzaUrl) {
  const image = new Image(); // or document.createElement('img');
  image.src = pizzaUrl;
  image.height = 50;
  const footer = document.querySelector('footer');
  footer.appendChild(image);
}
```

Le type du Asset Module configur√© dans le fichier **webpack.config.js** est **'asset/resource'**.  
Cela signifie que pour chaque fichier import√© dans le JS, il sera √©mis dans le "output directory", (ou "build directory"), g√©n√©ralement dans **/dist**, avec comme non de fichier qqch qui ressemble √† un hash (par exemple 151cfcfa1bd74779aadb.png) et leur chemins (paths) seront inject√© dans le bundle.

Dans l'exemple, le chemin de l'image **pizza2.png** lors de l'ex√©cution de l'application sera donn√© dans la variable **pizzaImage**.

Veuillez mettre √† jour votre site de la pizzeria pour afficher cette image dans le footer : <LinkFile name="pizza2.jpg" target="_blank" download>Pizza √† ajouter dans le footer [R.38]</LinkFile>.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**modern-dynamic-hmi**".

En cas de souci, vous pouvez acc√©der au code de cette √©tape du tutoriel ici : [modern-dynamic-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/modern-dynamic-hmi).

Si vous souhaitez plus d'informations sur la gestion des assets via Webpack, vous pouvez le faire via les [Asset Modules](https://webpack.js.org/guides/asset-modules/) [[R.37]](/references/#r37).

# <InternalPageTitle> Exercice 2.6 : G√©n√©ration dynamique de la Homepage de myMovies </InternalPageTitle>

Faites un refactor de votre application **myMovies** afin de g√©n√©rer dynamiquement l'HTML des images et du texte au chargment d'**index.html**.

Afin de r√©aliser cet exercice nous vous proposons ces contraintes d'impl√©mentation :
-	Utilisez Webpack pour un frontend moderne, en utilisant le code l'exercice pr√©c√©dent (**/exercises/module2/2.1**).
-	Veuillez cr√©er un container statique, ou autrement dit un "wrapper", dans votre page **index.html** (par exemple une balise **main** ou une **div**).
-	Ajoutez dynamiquement les images et le texte associ√© √† votre **Homepage** dans votre "wrapper".

Veuillez faire un **commit** de votre code avec le message suivant : "**myMovies : module 2 : dynamic homepage**"".

NB : Le code de votre application web se trouve dans votre repository local et votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√© **/exercises/module2/2.2**.

#### ü§ù Tips
- Pensez √† faire l'import de vos images au sein de **index.js**.

# <InternalPageTitle> Exercice 2.7 : G√©n√©ration dynamique d'une table sur base d'un formulaire </InternalPageTitle>

Vous allez r√©aliser une application web permettant de g√©n√©rer une table sur base d'un formulaire.

Cr√©ez un formulaire permettant d'introduire un nombre de lignes, un nombre de colonne, et une chaine de base.  
Utilisez Bootstrap pour formater votre application web.  
N√©anmoins, si vous √™tes √† l'aise avec une autre technologie, n'h√©sitez pas √† cr√©er votre UI via du Vanilla CSS ou une autre librairie (tailwindcss‚Ä¶).

Voil√† √† quoi pourrait ressembler votre formulaire :

<ScrollableImage name="form.png" minWidth="182px" maxWidth="182px" />

Veuillez valider chacun des champs du formulaire lors du clic sur le bouton.

Si tous les champs sont valid√©s, veuillez g√©n√©rer et afficher une table HTML.   
Voici un exemple de r√©sultat :

<ScrollableImage name="table.png" minWidth="219px" maxWidth="219px" />

<br/>

Afin de r√©aliser cet exercice nous vous proposons ces contraintes d'impl√©mentation :
- Cr√©ez une 1√®re fonction nomm√©e **`createArray`** qui retourne un **Array** √† deux dimensions avec :
  - Comme valeur pour chaque √©l√©ment : une String au format `"chaine de base[num√©ro de ligne][num√©ro de colonne]"`,
  - Sur base de 3 param√®tres : le nombre de lignes, de colonnes, et la chaine de base √† afficher dans chaque √©l√©ment du tableau.
-	Cr√©ez une deuxi√®me fonction nomm√©e **`createHtmlTableAsString`** qui renvoie, sous forme de string, une table HTML bas√©e sur un **Array** ; vous lui passerez l'array cr√©√© par la 1√®re fonction.
-	Appelez ces deux fonctions afin d'afficher la table de mani√®re dynamique au sein d'un "wrapper" (une **div** est conseill√©e).


#### ü§ù Tips 
- Vous pouvez utiliser la propri√©t√© **.innerHtml** de votre wrapper pour afficher dynamiquement la table.
- Pour g√©rer le submit d'un formulaire, il existe plusieurs fa√ßons de le faire. La fa√ßon recommand√©e est d'√©couter les √©v√©nements de type "submit" sur le formulaire. Il est ainsi possible de faire un submit d'un formulaire √† l'aide de la touche **Enter**.
- Comment acc√©der aux champs de votre formulaire lors du "submit" ?  
La valeur d'un champs est accessible via la propri√©t√© **value** d'une **input**.
- N'oubliez pas que lors d'un clic sur un √©l√©ment qui am√®ne √† un "submit", le comportement par d√©faut du formulaire est de recharger la page. Vous devez donc stopper ce comportement par d√©faut pour assurer que le tableau que vous g√©n√©rez ne soit pas "effac√©".


Le code de votre application web doit se retrouver dans votre repository local et votre web repository (normalement appel√© **web2**) dans un r√©pertoire nomm√© **/exercises/module2/2.3**.

Veuillez faire un **commit** de votre code avec le message suivant : "**Exercice 2.3**"".

# <InternalPageTitle> üç¨ Exercice 2.8 : design responsive </InternalPageTitle>

N'h√©sitez pas √† lib√©rer votre cr√©ativit√© et am√©liorer la UI de la Homepage de **myMovies**.  
Voici quelques id√©es : 	
-	Assurez-vous qu'elle soit design responsive.
-	Pr√©voyez deux layouts : un layout pour les appareils mobile, un autre layout pour les appareils ayant un √©cran moyen voire large.
-	Peaufinez votre favicon, header, footer‚Ä¶