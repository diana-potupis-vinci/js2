---
title: "RESTful API"
description: "Introduction aux RESTful API en Node.js & Express"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part1"> Partie 1 </PathViewerItem>
    <PathViewerItem selected> b) RESTful API </PathViewerItem>
</PathViewer>

# b) Introduction aux RESTful API en Node.js & Express

<InternalPageMenu>
  <InternalPageMenuItem> Introduction aux RESTful API & conventions </InternalPageMenuItem>
  <InternalPageMenuItem> Configuration & d√©marrage d'une RESTful API en Express </InternalPageMenuItem>
  <InternalPageMenuItem> Les fonctions middleware en Express </InternalPageMenuItem>
  <InternalPageMenuItem> D√©finition d'une route en Express </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©ration de lecture </InternalPageMenuItem>
  <InternalPageMenuItem> Chemin et param√®tres de route </InternalPageMenuItem>
  <InternalPageMenuItem> Chemin et param√®tres de requ√™te </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©ration de cr√©ation & parsing du body </InternalPageMenuItem>
  <InternalPageMenuItem> Client REST </InternalPageMenuItem>
  <InternalPageMenuItem> R√©pondre avec un code de statut HTTP </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©rations de suppression & de modification </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.1 : Cr√©ation d'une RESTfull API non prot√©g√©e pour myMovies </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Exercice 1.2 : Gestion de la pagination, de l'ordre de pr√©sentation et du filtrage de films </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Introduction aux RESTful API & conventions </InternalPageTitle>
## C'est quoi une application REST ?
**REST** vient de **RE**presentational **S**tate **T**ransfer : c'est un style architectural pour construire des applications web extensibles, o√π les client et serveurs sont s√©par√©s.

Dans une application REST, une **interface uniforme** (ou API) est d√©finie afin de permettre √† des applications de coop√©rer.

Toute application REST se doit d'√™tre **stateless** : il n'y a pas d'enregistrement du contexte d'une session sur le serveur pour comprendre une requ√™te d'un client.  
Ainsi, les requ√™tes clientes ne d√©pendent pas d'un historique de requ√™tes, chaque requ√™te contient tout l'information n√©cessaire au serveur.

Une RESTful API met √† disposition des **op√©rations** sur des **ressources** via :
- des **URI** ; il y a donc une adresse unique pur chaque ressource ;
- des **m√©thodes HTTP** (GET, POST, DELETE, PATCH, PUT) repr√©sentant les op√©rations possibles ; on parle souvent d'op√©rations **CRUD**, des op√©rations de type **C**reate, **R**ead, **U**pdate ou **D**elete) ;
- des **repr√©sentations** des ressources compr√©hensibles tant par les clients que les serveurs ; les ressources sont repr√©sent√©es par leur "Media type" : **JSON**, **XML**, **HTML**, **TXT**, **JPEG**... ; dans le cadre de ce cours, les ressources seront quasi toujours repr√©sent√©es via du **JSON**.

## Conventions REST

 Le type d'op√©ration CRUD sur une ressource est d√©fini via la **m√©thode http** de la requ√™te.  
 Les op√©rations possibles sont :
  - GET = Read
  - POST = Create
  - DELETE = Delete üòâ
  - PATCH / PUT = Update
    - PATCH = Update d'une ou plusieurs propri√©t√©(s) de la ressources
    - PUT = Update de toutes les propri√©t√©s de la ressources, ou cr√©ation si la ressource n'existe pas
    
Voici un exemple d'application de ces conventions REST dans le cadre d'une RESTful API permettant de g√©rer des **posts** :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`posts`** | GET | READ ALL : Lire toutes les ressources de la collection |
| **`posts?userId=value`** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`posts/{id}`** | GET | READ ONE : Lire la ressource identifi√©e |
| **`posts`** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **`posts/{id}`** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **`posts/{id}`** | PUT | UPDATE ONE : Remplacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

<br/>

Si cette API est h√©berg√©e √† l'URL racine **https://jsonplaceholder.typicode.com/**, alors nous pourrions identifier une ressource de type **posts** de cette fa√ßon : **https://jsonplaceholder.typicode.com/posts/10**.

Pour lire cette ressource, il faudrait faire une requ√™te http de type **GET** sur cette **URL** : **https://jsonplaceholder.typicode.com/posts/10**.

# <InternalPageTitle> Configuration & d√©marrage d'une RESTful API en Express </InternalPageTitle>

## Cr√©ation d'un projet
Nous allons maintenant cr√©er notre toute premi√®re RESTful API pour g√©rer les donn√©es associ√©es √† une pizzeria, afin de b√©n√©ficier d'op√©rations sur des ressources de type "pizzas".

Dans votre repo **web2**, veuillez cr√©er le r√©pertoire **`/tutorials/pizzeria/api`**.

Veuillez ouvrir un terminal au niveau de ce r√©pertoire.

Dans ce r√©pertoire, veuillez g√©n√©rer une application express nomm√©e **basic**.  
Pour ce faire :

```bash
npx express-generator --no-view basic
```

Veuillez installer les d√©pendances :
```bash
cd basic
npm i
```

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire **`/tutorials/pizzeria/api/basic`** (ou **`/web2/tutorials/pizzeria/api/basic`** si l'on consid√®re le nom du r√©pertoire du repo).

Nous allons d√©velopper des RESTful API qui ne poss√®dent pas de serveur de fichiers statiques.  
On n'a donc pas besoin d'avoir un r√©pertoire **`/public`** ni d'un serveur statique.  
On peut donc effacer le r√©pertoire **`/public`** et supprimer le middleware de serveur de fichiers statiques au sein de **`/app.js`** (en supprimant cette ligne) : 

```js
app.use(express.static(path.join(__dirname, 'public'))); 
```

## Fonctionnement d'une application Express

Nous allons maintenant nous attarder √† comprendre les concepts associ√©s √† l'utilisation d'Express, mais en focalisant sur ceux utiles aux applications REST.  
Voici comment une requ√™te faite √† une application Express est trait√©e :

<ScrollableImage name="express-flow.png" minWidth="800px" maxWidth="800px" />

<figcaption>Flux d'une requ√™te vers une application Express [R.51]</figcaption>

Dans ce flux de traitement d'une requ√™te, la responsabilit√© des d√©veloppeurs est de s'occuper de la partie "Middleware".

La grande majorit√© du code √©crit sera du "routing middleware" : notre code s'occupera de r√©pondre √† des requ√™tes clientes pour diff√©rentes URLs et m√©thodes HTTP (GET, POST...).

On l'a d√©j√† vu, la configuration d'une application Express, comme toutes applications Node.js, est faite au sein de **`package.json`**.

En fonction de comment est configur√© l'application, on la d√©marrera via **`npm start`**, **`npm run dev`**, **`npm run build`**...

Un **serveur web int√©gr√©** √† nos applications Express est d√©marr√© au sein du fichier **`bin/www`**.

C'est ce fichier que vous devez mettre √† jour si par exemple vous souhaitez que votre application fonctionne sur un port diff√©rent que le port par d√©faut **3000**.

Un serveur int√©gr√© est diff√©rent d'une application web offerte par un serveur standalone comme Apache, Tomcat... C'est un serveur tr√®s l√©ger d√©di√© √† votre application.

# <InternalPageTitle> Les fonctions middleware en Express </InternalPageTitle>
## C'est quoi une fonction middleware ?

Les fonctions middleware s'occupent du traitement des requ√™tes des clients et de la pr√©paration des r√©ponses :

<ScrollableImage name="middlewares.jpg" minWidth="638px" maxWidth="638px" />

<figcaption>Les fonctions Middleware et Express [R.52]</figcaption>

Une fonction middleware a acc√®s aux objets de la requ√™te et de la r√©ponse et peut utiliser la requ√™te et la r√©ponse pour ajouter, par exemple, un log, pour autoriser un utilisateur, pour parser des donn√©es Json vers des objets JS, pour servir des fichiers statiques, pour faire un traitement pour une route bien sp√©cifique...

Si une fonction middleware ne termine pas le cycle de requ√™te-r√©ponse, elle doit appeler **`next()`** pour permettre √† d'autres fonctions qui sont dans la queue de pouvoir √™tre ex√©cut√©es.

Voici les √©l√©ments associ√©s √† l'appel d'une fonction middleware :

<ScrollableImage name="middleware-function.png" minWidth="944px" maxWidth="944px" />

<figcaption>Une fonction middleware [R.53]</figcaption>

Il existe diff√©rents types de fonctions middleware ayant diff√©rents cas d'utilisation :
- **Application-level middleware** : la fonction middleware est li√©e √† l'objet **app** et peut s'appliquer √† toutes les requ√™tes.
- **Router-level middleware** : la fonction middleware est li√©e √† un objet de type **`express.router()`** et est tr√®s similaire au "application-level middleware", mais ne s'applique qu'√† un groupe de requ√™tes.
- **Error-handling middleware** : fonction de gestion des erreurs qui se d√©finit comme les fonctions ci-dessus (au niveau **app** ou **router**), mais qui contient un quatri√®me param√®tre nomm√© **error**.
- **Built-in middleware** : fonctions middleware mises √† disposition par Express directement. En voici quelques exemples :
  - **express.static** : pour servir des assets statiques ;
  - **express.json** : pour parser le body de requ√™tes en JSON vers des objets JS ;
  - **express.urlencoded** : pour parser des requ√™tes dont le body est de type "urlencoded" (type par d√©faut des formulaires) vers des objets JS.
- **Third-party middleware** : fonctions mises √† disposition par la communaut√© et installables via npm, comme par exemple la fonction middleware **cookieParser**.

La suite fournit quelques exemples de fonctions middleware qui seront soit plus tard rencontr√©es dans notre code, soit sont extraites de la documentation d'Express : [Using middleware](https://expressjs.com/en/guide/using-middleware.html) [[R.54]](/references/#r54).

## Application-level middleware : exemple
Voici une fonction middleware qui sera ex√©cut√©e √† chaque fois qu'il y a une requ√™te, quelque soit le chemin (ou path) associ√© √† la requ√™te :

```js
var¬†express¬†=¬†require('express');
var¬†app¬†=¬†express();
app.use((req,¬†res,¬†next) =>¬†{
¬†¬†console.log('Time:',¬†Date.now());
¬†¬†next();
});
```

## Router-level middleware : exemple
Voici une partie du code qui se trouverait au sein d'un router de pizzas, dans le fichier **/routes/pizzas.js** :

```js
var¬†router¬†=¬†express.Router();

router.use((req,¬†res,¬†next)¬†=> {
¬†¬†console.log('Time:',¬†Date.now());
¬†¬†next();
});

router.get('/',(req,¬†res,¬†next)¬†=> {
¬†¬†return¬†res.json(menu);
});
```

La premi√®re fonction middleware ne contient pas de m√©thode HTTP, ni de chemin, elle s'applique donc √† toutes les routes associ√©es au router de pizzas.  
Voici le code qui permettrait, dans **/app.js**, d'appeler le router de pizzas :

```js
var pizzaRouter = require('./routes/pizzas');
app.use('/pizzas', pizzaRouter);
```

Si le router est utilis√© de cette fa√ßon, en relisant l'avant-dernier snippet, on voit que : 
- la premi√®re fonction (o√π il y a un `console.log`) s'applique donc √† toutes les routes qui commencent par **/pizzas** ;
- la deuxi√®me fonction middleware s'appliquent seulement aux requ√™tes de type **GET** sur la route (ou le chemin) **/pizzas** (√©quivalent de la route **/pizzas/**).

## Error-handling middleware : exemple
Ce type de middleware est √† d√©finir apr√®s tous les middlewares pouvant g√©n√©rer une erreur et est appel√© via **`next(err)`** dans une fonction middleware o√π un souci est d√©tect√©.

Voici la d√©finition d'un gestionnaire d'erreurs :

```js
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
});
```

Attention, il y a bien 4 param√®tres au lieu des 3 habituels pour les autres types de fonctions middleware.

## Built-in middleware & third-party middleware : exemple
Dans **app.js**, on trouve pas mal d'exemples de ces types de middleware. Ils sont comment√©s ci-dessous dans le code :

```js
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var app = express();

app.use(logger('dev')); //¬†HTTP request logger
app.use(express.json()); //¬†Parse requests with JSON payloads
app.use(express.urlencoded({ extended: false })); //¬†Parse requests with URL-
                                                  // encoded payload 
app.use(cookieParser()); //¬†Parse cookie header (req.cookies)
app.use(express.static(path.join(__dirname, 'public'))); //¬†Serve static assets
```

# <InternalPageTitle> D√©finition d'une route en Express </InternalPageTitle>
## D√©finition d'une route
Le routing, ou routage, contr√¥le la r√©ponse √† une requ√™te client pour un chemin et une m√©thode HTTP. Le chemin est aussi appel√© **endpoint** ou **URI** ou **PATH**.

On va d√©finir une route soit sur l'objet **app**, soit sur un **router**.  
Un objet de type **router** permet de regrouper toutes les routes associ√©es √† un type de ressources.

On d√©finit une route de cette fa√ßon : **`app.`** ou **`router.`**  **`METHOD(PATH, MIDDLEWARE_FUNCTION)`**.

üëç Dans notre cours, nous vous recommandons d'organiser vos routes par type de ressources et donc de mettre en place des routers.

# <InternalPageTitle> Op√©ration de lecture </InternalPageTitle>

Nous souhaitons par commencer √† d√©velopper une op√©ration permettant de lire toutes les ressources de type "pizzas".  
Veuillez cr√©er un router pour traiter des ressources **/pizzas** au sein de **`/routes/pizzas.js`**.  
Le plus simple est d'adapter **`indexRouter`** dans **`app.js`** en **`pizzaRouter`** et **`/routers/index.js`** en **`/routes/pizzas.js`**.  
NB : Il est aussi possible de partir de rien et de cr√©er **`pizzaRouter`** dans **`app.js`** et **`/routes/pizzas.js`**.

Pour l'op√©ration de lecture de toutes les pizzas, selon les conventions REST, il faut faire une requ√™te de type **`GET /pizzas`**. Le router de **`/routes/pizzas.js`** doit donc offrir une route renvoyant toutes les pizzas qui existent dans le menu.

Pour d√©marrer, nous souhaitons une application basique qui ne g√®re pas la persistance des donn√©es. Le menu sera donc un array d'objets, chaque objet repr√©sentant une pizza.

Notre op√©ration de lecture de pizza va renvoyer du JSON au client, c'est √† dire une repr√©sentation textuelle d'un array d'objets. Nous verrons plus tard ce qu'est r√©ellement le JSON. A ce stade-ci, il est suffisant de conna√Ætre la fonction d'Express qui permet √† un objet JS de circuler sur le r√©seau : **`res.json()`**.

Voici le code du router **`/routes/pizzas.js`** :
```js
var express = require('express');
var router = express.Router();

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

// Read all the pizzas from the menu
router.get('/', (req, res, next) => {
  console.log('GET /pizzas');
  res.json(MENU);
});

module.exports = router;
```

Et voici le code de **app.js** (les parties modifi√©es sont surlign√©es) :

```js numbered highlighting="6,16"
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var pizzaRouter = require('./routes/pizzas');
var usersRouter = require('./routes/users');

var app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/pizzas', pizzaRouter);
app.use('/users', usersRouter);

module.exports = app;
```

Veuillez d√©marrer l'API (par d√©faut elle est configur√©e sur le port 3000 au sein de **`bin/www`**) :

```bash
npm start
```

Pour consommer l'op√©ration de lecture via un browser, nous pouvons lire toutes les ressources de type "pizzas" ici :
[http://localhost:3000/pizzas](http://localhost:3000/pizzas)

# <InternalPageTitle> Chemin et param√®tres de route </InternalPageTitle>

Les **route parameters** sont des segments d'une URL qui sont utilis√©s pour capturer une valeur sp√©cifi√©e √† leur position dans l'URL. On r√©cup√®re ces param√®tres via l'objet **`req.params`**.

Pour notre pizzeria, nous souhaitons pouvoir lire une pizza identifi√©e par son **id**.

Nous allons donc ajouter le param√®tre de route **id**.  
En respect des conventions REST, un client, pour faire appel √† cette op√©ration, devra faire une requ√™te du genre : **`GET /pizzas/2`**.

Voici la nouvelle route permettant de traiter de cette op√©ration, √† ajouter dans le router **`/routes/pizza.js`** :
```js
// Read the pizza identified by an id in the menu
router.get('/:id', (req, res) => {
  console.log(`GET /pizzas/${req.params.id}`);

  const indexOfPizzaFound = MENU.findIndex((pizza) => pizza.id == req.params.id);

  if (indexOfPizzaFound < 0) return res.sendStatus(404);

  res.json(MENU[indexOfPizzaFound]);
});
```

Veuillez red√©marrer l'API (**`CTRL c`** puis **`npm start`**).

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire la ressource de type "pizzas" identifi√©e par **2** dans le menu ainsi :
[http://localhost:3000/pizzas/2](http://localhost:3000/pizzas/2)

Le browser fait bien une requ√™te du genre : **`GET /pizzas/2`**.  
Le param√®tre de la route "2" est r√©cup√©r√© dans l'URL de la route par Express et est offert via **`req.params.id`**. 

N'h√©sitez pas √† faire une requ√™te pour un identifiant n'existant pas de le menu pour voir ce qui se passe : [http://localhost:3000/pizzas/666](http://localhost:3000/pizzas/666).

# <InternalPageTitle> Chemin et param√®tres de requ√™te </InternalPageTitle>

Les **query parameters** sont des param√®tres qui peuvent √™tre ajout√©s √† une URL.  
On r√©cup√®re ces param√®tres via l'objet **`req.query`**.

Pour notre pizzeria, nous souhaitons pouvoir lire toutes les ressources de type "pizzas" tri√©es par ordre ascendant ou descendant du titre.

En respect des conventions REST, un client, pour faire appel √† cette op√©ration, devra faire une requ√™te du genre : 
- pour le tri ascendant : **`GET /pizzas?order=title`** ;
- pour le tri descendant : **`GET /pizzas?order=-title`**.

Il n'y a donc pas de nouvelle route √† ajouter ici. En effet, √ßa reste une requ√™te de type GET sur la route **`/pizzas`**. 

Veuillez donc mettre √† jour **/routes/pizza.js** pour la lecture de toutes les pizzas :
```js
/* Read all the pizzas from the menu
   GET /pizzas?order=title¬†:¬†ascending order¬†by¬†title
¬†  GET /pizzas?order=-title¬†:¬†descending order¬†by¬†title
*/
router.get('/', (req, res, next) => {
  const orderByTitle =
    req?.query?.order?.includes('title')
      ? req.query.order
      : undefined;
  let orderedMenu;
  console.log(`order by ${orderByTitle ?? 'not requested'}`);
  if (orderByTitle)
    orderedMenu = [...MENU].sort((a, b) => a.title.localeCompare(b.title));
  if (orderByTitle === '-title') orderedMenu = orderedMenu.reverse();

  console.log('GET /pizzas');
  res.json(orderedMenu ?? MENU);
});
```

Veuillez red√©marrer l'API (**`CTRL c`** puis **`npm start`**).

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire toutes les ressources de type "pizzas" tri√©es par leur titre de mani√®re descendante :
[http://localhost:3000/pizzas?order=-title](http://localhost:3000/pizzas?order=-title).

N'h√©sitez pas √† tester d'autres tris.

# <InternalPageTitle> Op√©ration de cr√©ation & parsing du body </InternalPageTitle>

Nous souhaitons d√©velopper une op√©ration permettant de cr√©er une ressource de type "pizzas".  
Selon les conventions REST, il faut faire une requ√™te de type **`POST /pizzas`** qui offre une repr√©sentation de la ressource √† cr√©er. La repr√©sentation utilis√©e est le JSON que nous verrons plus en d√©tails plus tard.  
Si nous souhaitons cr√©er une ressource dont le titre est "Magic Green" et le contenu est "Epinards, Brocolis, Olives vertes, Basilic", la repr√©sentation de la ressource √† cr√©er sera la suivante :
```json
{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Selon les conventions REST, une requ√™te de cr√©ation est de type **POST** et contient ses **param√®tres 
au sein du body** de la requ√™te.

**`/routes/pizzas.js`** doit offrir une nouvelle route permettant d'ajouter une nouvelle pizza au menu, qui est un array d'objets. Une nouvelle pizza doit donc √™tre ajout√©e √† une variable, un array, qui est contenu dans la m√©moire vive de votre machine.  
Lorsque l'ajout d'une pizza au menu a r√©ussi, nous souhaitons renvoyer la repr√©sentation de la nouvelle ressource au client. Ainsi, le client aura notamment acc√®s √† l'**id** de la pizza cr√©√© par l'API.

Voici le code du router **`/routes/pizzas.js`** pour la nouvelle op√©ration, veuillez le rajouter dans votre application :
```js
// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  console.log('POST /pizzas');

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const lastItemIndex = MENU?.length !== 0 ? MENU.length - 1 : undefined;
  const lastId = lastItemIndex !== undefined ? MENU[lastItemIndex]?.id : 0;
  const nextId = lastId + 1;

  const newPizza = {
    id: nextId,
    title: title,
    content: content,
  };

  MENU.push(newPizza);

  res.json(newPizza);
});
```

La repr√©sentation de la ressource √† cr√©er est pars√©e dans l'objet **`req.body`** gr√¢ce √† la fonction middleware **`express.json()`** appel√©e dans **`/app.js`** :
```js
app.use(express.json());
```

Il est donc important de ne pas retirer cette ligne lorsque l'on cr√©e une RESTful API.

OK, c'est bien, mais comment tester ce nouveau code ?

Le browser permet de facilement cr√©er des requ√™tes de type **GET**, mais pas des requ√™tes de type **POST**...   
Nous avons donc besoin d'un client l√©ger permettant de faire des requ√™tes HTTP.

# <InternalPageTitle> Client REST </InternalPageTitle>

## Introduction
Dans le cadre de ce cours, tout comme g√©n√©ralement dans un environnement professionnel, nous souhaitons pouvoir d√©velopper une API ind√©pendamment du d√©veloppement d'une IHM.

En effet, cela prendrait trop de temps de devoir d√©velopper un frontend (HTML / JavaScript / CSS) pour tester nos API.

Nous allons donc utiliser un client l√©ger permettant de faire des requ√™tes √† nos API.  
Il en existe de nombreux, comme REST Client [[R.55]](/references/#r55) ou Postman [[R.56]](/references/#r56).

Pour ce cours, nous vous pr√©sentons et recommandons d'utiliser REST Client pour √©crire et ex√©cuter vos requ√™tes HTTP.

## REST Client
Dans le cadre de ce cours, nous utilisons REST Client [[R.55]](/references/#r55) de Visual Studio Code pour tester nos API.

Pour installer REST Client au sein de VS Code, veuillez cliquer sur l'onglet **Extensions**. 

Recherchez l'extension **REST Client** et cliquez sur **Install**.

Quelques notions pour utiliser REST Client :
- Il faut cr√©er un fichier **.http** (ou **.rest**) contenant les requ√™tes vers vos RESTful APIs.  
NB : Il est appropri√© de cr√©er un fichier par par type de ressources.
- Chaque requ√™te est introduite par **###** (3 "**#**"" ou plus) ; voici la requ√™te permettant de lire toutes les pizzas :
```http
### Read all pizzas
GET http://localhost:3000/pizzas
```
- Pour ex√©cuter une requ√™te, il suffit de cliquer sur **Send Request**.
- Lorsqu'on envoie des donn√©es au format JSON, il est important d'avoir un espace avant les accolades (avant le "**&#123;**" ).
- On peut d√©finir des "**File variables**" via ce genre de syntaxe : **@baseUrl = http://localhost:3000**.
- Pour utiliser la variable **baseUrl**, il suffit de la mettre entre double accolades. Par exemple, voici la requ√™te permettant de lire toutes les pizzas :  
```http
### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas
```

Nous allons maintenant tester l'API de la pizzeria que nous avons cr√©√©e pour toutes ses op√©rations.

Au sein de VS Code, dans votre projet **/tutorials/pizzeria/api/basic**, veuillez cr√©er un r√©pertoire nomm√© **REST Client**. Dans ce r√©pertoire, veuillez cr√©er un fichier nomm√© **pizzas.http**.

Dans **pizzas.http**, veuillez ajouter cette requ√™te pour la lecture de toutes les pizzas et ex√©cutez la : 
```http
### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas
```

Est-ce que cela fonctionne bien ?  Avez vous bien d√©marr√© votre API ?  
Vous devriez obtenir le m√™me r√©sultat que si vous acc√©diez √† votre API √† l'aide du browser.

Au sein de **pizzas.http**, veuillez ajouter ces deux requ√™tes pour la lecture de toutes les pizzas en les triant selon leur titre :
```http
### Read all pizzas sorted by title (ascending)
GET {{baseUrl}}/pizzas/?order=+title

### Read all pizzas sorted by title (descending)
GET {{baseUrl}}/pizzas/?order=-title
```

Veuillez ex√©cuter ces deux requ√™tes.

Il semble que nous sommes pr√™ts pour cr√©er une requ√™te appelant l'op√©ration de cr√©ation d'une pizza.

Au sein de **pizzas.http**, veuillez ajouter cette requ√™te pour la cr√©ation d'une pizza :
```http
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

On remarque qu'il est important de mettre une ligne vide avant les accolades repr√©sentant le body de la requ√™te.  N'h√©sitez pas √† tester cette requ√™te avec ou sans la ligne vide pour y croire.

üí≠ Comment tester que le bon fonctionnement de l'op√©ration de cr√©ation ?

Et bien il suffit d'ex√©cuter l'op√©ration de lecture de toutes les pizzas üòé !
Si la nouvelle ressource appara√Æt, c'est qu'elle a bien √©t√© cr√©√©e !
Faites le test.

# <InternalPageTitle> R√©pondre avec un code de statut HTTP </InternalPageTitle>

On ne peut pas toujours renvoyer du JSON suite √† une requ√™te client ainsi qu'un code HTTP correspondant au fait que tout est OK ("200 OK").

Quand vous ex√©cutez cette requ√™te :
```http
### Read all pizzas with File variable
GET {{baseUrl}}/pizzas
```

Vous faites appel √† l'op√©ration de lecture de toutes les pizzas. La derni√®re ligne de cette op√©ration est la suivante :
```js
res.json(orderedMenu ?? MENU);
```

En fait, la fonction **json** renvoie une r√©ponse au format JSON, mais de plus, elle renvoie un "status code" **200** indiquant au client que tout s'est bien pass√©.

Au sein de **pizzas.http**, veuillez ajouter cette requ√™te pour tenter de cr√©er une pizza en oubliant un param√®tre :
```http
### Create a pizza which lacks a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Veuillez ex√©cuter cette requ√™te. Que se passe-t-il ?  
On r√©cup√®re un code d'erreur "400 Bad Request".

En effet, lorsqu'on omet un param√®tre dans la repr√©sentation de la ressource √† cr√©er, voici les lignes de code amenant au renvoi du code d'erreur 400 au sein de **pizzas.js** :
```js numbered highlighting="3,4,8"
// Create a pizza to be added to the menu.
router.post('/', (req, res) => {
  const title = req?.body?.title?.length !== 0 ? req.body.title : undefined;
  const content = req?.body?.content?.length !== 0 ? req.body.content : undefined;

  console.log('POST /pizzas');

  if (!title || !content) return res.sendStatus(400); // error code '400 Bad request'

  const lastItemIndex = MENU?.length !== 0 ? MENU.length - 1 : undefined;
  const lastId = lastItemIndex !== undefined ? MENU[lastItemIndex]?.id : 0;
  const nextId = lastId + 1;

  const newPizza = {
    id: nextId,
    title: title,
    content: content,
  };

  MENU.push(newPizza);

  res.json(newPizza);
});
```

Le client est donc bien inform√© qu'il y a eu un probl√®me lors de l'ex√©cution de l'op√©ration.   
Il pourrait par exemple utiliser cette information pour pr√©senter un message d'erreur au niveau d'une IHM.

Voici les grandes cat√©gories de "status codes" :
- R√©ponses informatives : **100-199**
- R√©ponses en cas de succ√®s : **200-299**
- Redirections : **300-399**
- Erreurs du client : **400-499**
- Erreurs du serveur : **500-599**

Voici les "status codes" que nous allons g√©n√©ralement utiliser :
- **200 OK** : tout s'est bien pass√©, Express ajoute ce code automatiquement pour nous quand nous utilisons une m√©thode comme **res.json()**.
- **400 Bad Request** : pour indiquer au client que la requ√™te contient des param√®tres non valides ou n'est pas compl√®te.
- **401 Unauthorized** : pour indiquer au client qu'il doit s'authentifier pour acc√©der √† cette op√©ration. On renvoie aussi ce code d'erreur quand un client fournit un mauvais username ou password.
- **403 Forbidden** : le client est connu du serveur, mais il n'a pas les privil√®ges pour acc√©der √† cette op√©ration (par exemple, le client n'est pas admin et tente d'acc√©der √† une op√©ration seulement accessible √† un admin).
- **404 Not Found** : la ressource demand√©e n'existe pas, bien que l'URL semble valide.
- **409 Conflict** : l'√©tat du serveur entre en conflit avec la requ√™te. Par exemple, la requ√™te demande de cr√©er un utilisateur qui existe d√©j√†.
- **500 Internal Server Error** : le serveur a rencontr√© une erreur qu'il ne peut pas r√©gler. Par exemple, le serveur de base de donn√©es ne r√©pond pas et ne permet donc pas d'acc√©der aux ressources.

# <InternalPageTitle> Op√©rations de suppression & de modification </InternalPageTitle>

## Op√©ration de suppression
Nous souhaitons d√©velopper une op√©ration permettant de supprimer une ressource de type "pizzas" √† l'aide de son identifiant.  
Selon les conventions REST, il faut faire une requ√™te de type **`DELETE /pizzas/{id}`** contenant l'identifiant de la ressource √† supprimer au sein de l'URL comme "path parameter".

Une op√©ration de suppression ne contient donc pas de body et est de type DELETE. 

Voici le code du router **/routes/pizzas.js** pour la nouvelle op√©ration, veuillez la rajouter dans votre application :
```js
// Delete a pizza from the menu based on its id
router.delete('/:id', (req, res) => {
  console.log(`DELETE /pizzas/${req.params.id}`);

  const foundIndex = MENU.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const itemsRemovedFromMenu = MENU.splice(foundIndex, 1);
  const itemRemoved = itemsRemovedFromMenu[0];

  res.json(itemRemoved);
});
```

Au sein de **pizzas.http**, veuillez ajouter cette requ√™te pour supprimer la pizza poss√©dant l'identifiant "2" :
```http
### Delete pizza identified by 2
DELETE {{baseUrl}}/pizzas/2
```

Veuillez ex√©cuter cette requ√™te et v√©rifier que la pizza a bien √©t√© supprim√©e.

## Op√©ration de modification
Nous souhaitons d√©velopper une op√©ration permettant de modifier une ressource de type "pizzas" √† l'aide de son identifiant et de nouvelles valeurs pour ses propri√©t√©s.  
Selon les conventions REST, comme on accepte de modifier que certaines des propri√©t√©s d'une pizza, qu'il ne faut pas fournir toutes les propri√©t√©s d'une pizza, il faut faire une requ√™te de type **`PATCH /pizzas/{id}`** contenant 
l'identifiant de la ressource √† supprimer au sein de l'URL comme "path parameter" ainsi que les nouvelles donn√©es au sein du body de la requ√™te.

Si nous souhaitons modifier une ressource identifi√©e par 6 en fournissant un nouveau titre "Magic Green 2", la repr√©sentation des donn√©es de la ressource √† modifier sera la suivante :
```json
{
    "title":"Magic Green 2"
}
```

Selon les conventions REST, la requ√™te de modification est de type PATCH et contient ses param√®tres au sein du body de la requ√™te.

Voici le code du router **/routes/pizzas.js** pour la nouvelle op√©ration, veuillez la rajouter dans votre application :
```js
// Update a pizza based on its id and new values for its parameters
router.patch('/:id', (req, res) => {
  console.log(`PATCH /pizzas/${req.params.id}`);

  const title = req?.body?.title;
  const content = req?.body?.content;

  console.log('POST /pizzas');

  if ((!title && !content) || title?.length === 0 || content?.length === 0) return res.sendStatus(400);

  const foundIndex = MENU.findIndex(pizza => pizza.id == req.params.id);

  if (foundIndex < 0) return res.sendStatus(404);

  const updatedPizza = {...MENU[foundIndex], ...req.body};

  MENU[foundIndex] = updatedPizza;

  res.json(updatedPizza);
});
```

Au sein de **pizzas.http**, veuillez ajouter cette requ√™te pour modifier la pizza poss√©dant l'identifiant "6" :
```http
### Update the pizza identified by 6
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json

{
    "title":"Magic Green 2"
}
```

Veuillez ex√©cuter cette requ√™te et v√©rifier que la pizza a bien √©t√© modifi√©e.

üí≠ Cela ne fonctionne pas ?  
Avez vous pr√©c√©demment ex√©cut√© la requ√™te permettant de cr√©er une sixi√®me pizza.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**api-basic**".

En cas de souci, vous pouvez acc√©der au code du tutoriel ici : [api-basic](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/basic).

# <InternalPageTitle> Exercice 1.1 : Cr√©ation d'une RESTfull API non prot√©g√©e pour myMovies </InternalPageTitle>

Veuillez continuer le d√©veloppement de **myMovies**. Vous allez cr√©er la premi√®re version de la RESTful API de **myMovies**, sous Express, afin de mettre √† disposition toutes les op√©ration de type CRUD sur des films.


Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :
-	Veuillez cr√©er une RESTful API pour la collection de films, qui r√©ponde sur le port par d√©faut d'une application Express (3000), et qui couvre ces op√©rations :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **films** | GET | READ ALL : Lire toutes les ressources de la collection |
| **films?minimum-duration=value** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`films/{id}`** | GET | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **`films/{id}`** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **`films/{id}`** | PATCH | UPDATE ONE : Mettre √† jour les propri√©t√©s de la ressource par les valeurs donn√©es dans la requ√™te, pour une ou plusieurs propri√©t√©s |

- Une ressource de type **films** doit contenir les propri√©t√©s suivantes :
  - **id** : un entier 
  - **title** : titre du film (String)
  - **duration** : dur√©e du film en minutes ; elle doit √™tre un nombre positif (pas une string !).
  - **budget** : pour informer du co√ªt qu'a cout√© la production du film, en millions ; le budget doit √™tre un nombre positif (pas une string !).
  - **link** : pour donner une URL vers la description du film (lien vers imdb, rottentomatoes ou autre)
-	Les ressources ne doivent pas persister : d√®s lors, ajoutez les donn√©es associ√©es aux films dans un array.
- Veuillez bien valider les param√®tres re√ßu par les op√©rations de vos API (v√©rifier par exemple que **budget** et **duration** sont des **number** positifs) et veuillez renvoyer les bons status codes en cas d'erreur.
-	Veuillez tester toutes les fonctions de la RESTful API pour la collection de films √† l'aide du REST Client dans VS Code (extension √† installer au sein de VS Code). Veuillez ajouter vos requ√™tes au sein du fichier **films.http** dans le r√©pertoire **REST Client** du dossier associ√© √† cet exercice.

#### ü§ù Tips
- N'h√©sitez pas √† utiliser le g√©n√©rateur d'applications d'Express pour initier votre projet.
- D√©veloppez les op√©rations de votre API de mani√®re incr√©mentale : testez une op√©ration via REST Client avant de passer √† une nouvelle op√©ration.
- Pour le filtre sur les films, vous allez r√©cup√©rer un param√®tre de requ√™te.  
‚ö° Attention, le signe **-** est un op√©rateur en JS, vous ne pouvez pas r√©cup√©rer le param√®tre de requ√™te via **`req.query.minimum-duration`**...  
üí≠ Mais alors comment faire ?  
On acc√®de aussi au propri√©t√© d'un objet √† l'aide d'un array, ici √ßa serait via **`req.query['minimum-duration']`**.
- N'h√©sitez pas √† vous inspirer du code du tutoriel [api-basic](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/basic).
- Pour v√©rifier le type d'une variable, n'h√©sitez pas √† utiliser l'op√©rateur **`typeof`**.

Le code de votre application web doit se trouver dans votre repository local et votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√© **/exercises/module4/4.1**.

Veuillez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 4 : basic API**".

# <InternalPageTitle> üç¨ Exercice 1.2 : Gestion de la pagination, de l'ordre de pr√©sentation et du filtrage de films </InternalPageTitle>

N'h√©sitez pas, c'est optionnel, de g√©rer de nouvelles op√©rations au sein de votre RESTful API de **myMovies** :
-	Filtrez tous les films qui commencent par une certaines cha√Ænes de caract√®res.
-	G√©rez l'ordre de pr√©sentation des films.

#### ü§ù Tips
Besoin d'inspiration pour l'aspect filtrage et la gestion de l'ordre des ressources ? [REST API Guide](https://dev.to/drminnaar/rest-api-guide-14n2) [[R.58]](/references/#r58).

Veuillez faire un **commit** de votre code avec le message suivant : "**myMovies : module 4 : ordering & filtrering**".

üç¨ Et si vraiment vous avez encore du temps et souhaitez d√©j√† approfondir les RESTful APIs, n'h√©sitez pas aussi √† impl√©menter la gestion de la pagination.