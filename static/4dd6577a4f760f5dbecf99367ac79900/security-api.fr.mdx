---
title: "S√©curisation API"
description: "S√©curisation d'une RESTful API"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part4"> Partie 4 </PathViewerItem>
    <PathViewerItem selected> C) S√©curitsation d'une API </PathViewerItem>
</PathViewer>

<InternalPageMenu>
  <InternalPageMenuItem> Protection contre les attaques XSS </InternalPageMenuItem>
  <InternalPageMenuItem> S√©curisation des passwords </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 4.3 : S√©curisation de l'API de myMovies </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Exercice 4.4 : Auto-refresh de myMovies </InternalPageMenuItem> 
  <InternalPageMenuItem> üç¨ Exercice 4.5 : Gestion de la navigation lors de l'auto-refresh de myMovie </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Exercice 4.6 : L'essentiel du cours en action </InternalPageMenuItem> 
</InternalPageMenu>

# c) S√©curisation d'une RESTful API

La s√©curisation d'API est une probl√©matique complexe.  
Nous n'allons pas aller dans les d√©tails de cette probl√©matique, juste offrir une solution √† deux probl√©matiques simples √† traiter.

# <InternalPageTitle> Protection contre les attaques XSS </InternalPageTitle>

## Une attaque XSS, c'est quoi ?

Les attaques **XSS**, ou **Cross-Site Scripting**, sont un type d'injection de scripts malicieux dans une application web.

Imaginez le forum web d'une banque et ce sc√©nario :

<ScrollableImage name="xss.png" minWidth="500px" maxWidth="700px" />

L'API de la banque permet d'enregistrer des messages qui sont associ√©s √† des forums sur lesquels leurs clients peuvent poster des messages.  
Si l'API de la banque √©tait mal s√©curis√©e et qu'elle permettait d'enregistrer n'importe quels types d'information en tant que "messages" du forum, il serait possible √† un attaquant d'injecter du JS malicieux dans l'API.  
Plus tard, lors de l'affichage des messages par le forum de la banque (`https://forum.my-bank.com `), le JS malicieux pourra s'ex√©cuter dans le browser de n'importe quel utilisateur.  
Vous avez vu que via du JS, on peut envoyer de l'information n'importe o√π, notamment √† l'aide de **fetch**. Ce qui permettrait donc √† un hacker, via son script malicieux, d'envoyer des cookies contenant des infos sensibles √† son API malicieuse, en vue de futures attaques encore plus diaboliques, comme notamment vider le compte en banque d'utilisateurs.

La protection contre des attaques XSS se fait √† diff√©rents niveaux. Ca n'est pas l'objet de ce cours de voir cela en d√©tails, mais nous verrons un technique simple pour √©viter certaines attaques XSS.

## R√©aliser une attaque XSS
Nous allons maintenant r√©aliser une attaque XSS sur le site de la pizzeria.

Veuillez lancer le frontend **jwt-fetch** et le backend **auths** du site de la pizzeria. En cas de soucis :
- pour le frontend : [jwt-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch).
- pour l'API : [auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths).

Evidemment, un hackeur, pour tenter l'attaque XSS, doit d'abord trouver un moyen d'usurper la session d'**admin**. Nous ne verrons pas dans ce cours le genre d'attaques qui permettrait de le faire. Nous allons consid√©rer que cette premi√®re attaque est r√©ussie et nous allons prendre le r√¥le d'un hackeur pouvant acc√©der au compte **admin**.

Veuillez vous loguer √† l'aide du compte **admin** (et le password **admin**).  
Veuillez vous rendre sur la page **Add a pizza**.

Pour le titre de la pizza, vous pouvez ajouter n'importe quoi.
Dans le contenu de la pizza, veuillez ajouter cela et soumettre : 

```text
<img src="#" onerror="alert('You have been hacked !')">
```

En fait, nous avons ajout√© une balise **`img`** contenant du inline JS. **`oneerror`** est un gestionnaire d'√©v√©nements qui sera d'office appel√© car la source (**`src="#"`** ) donn√© √† **`img`** n'est pas une image.

Maintenant, tout utilisateur connect√© ou pas qui se loguera sur le site va ex√©cuter ce script "malicieux". Il verra le pop-up appara√Ætre avec le message "You have been hacked !".  
En effet, le menu des pizzas, tel qu'il est construit, est bas√© sur toutes les ressources de type "pizzas" renvoy√©es par l'API, dont une des pizzas contient le JS malicieux qui est ex√©cut√© dans une cellule de la table via ce code de la **HomePage** de l'IHM :
```js highlighting="7"
function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}
```

## Emp√™cher les attaques XSS

Par rapport √† l'attaque pr√©c√©dente, le plus simple pour prot√©ger de l'attaque pourrait √™tre de faire en sorte que l'application cliente n'interpr√®te pas d'HTML / JS / CSS envoy√© par l'API.

Ici, dans la **HomePage**, on utilise la propri√©t√© **`innerHTML`** d'une **`td`**. Ainsi, l'HTML et l'inline JS associ√© est ex√©cut√©. Si l'on utilisais la propri√©t√© **`innerText`** des **`td`**, alors, ni l'HTML et le JS serait interpr√©t√© par le browser, et donc pas de possibilit√© de script malicieux au niveau de la **HomePage**.

Oui, mais si nous allions vers cette solution, cela serait probl√©matique si nous souhaitions r√©ellement d√©velopper plusieurs applications clientes, il faudrait toujours faire attention √† cette contrainte.

D√®s lors, nous allons pr√©f√©rer la solution o√π nous s√©curisons l'API. Ainsi, peu importe l'application cliente d√©velopp√©e, il devrait y avoir moins d'angles d'attaques.

Au niveau de l'API, nous allons √©chapper les caract√®res dangereux, principalement **`"`**, **`'`**, **`&`**, **`<`**, **`>`**.

Nous allons utiliser la librairie **[escape-html](https://www.npmjs.com/package/escape-html)** sous Node.js √©chappant les string pour une utilisation des string transform√©es en HTML.

Nous allons maintenant continuer le d√©veloppement de l'API [auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths) et la s√©curiser.

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/api/safe** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/api/auths** (ou [auths](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/auths).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/api/safe**.

Veuillez installer la librairie **escape-html** au sein de votre projet **safe** :
```bash
npm i escape-html
```

Nous allons supprimer, s'il existe, le fichier reprenant le code malicieux introduit pr√©c√©demment : veuillez supprimer le fichier **/data/pizzas.json**.

Nous allons √† pr√©sent mettre √† jour le mod√®le de pizzas pour √©chapper les caract√®res dangereux.
Veuillez modifier **/models/pizzas.js** :
```js highlighting="1,9-10"
const escape = require('escape-html');
// other bits of code

function createOnePizza(title, content) {
  const pizzas = parse(jsonDbPath, defaultPizzas);

  const createdPizza = {
    id: getNextId(),
    title: escape(title),
    content: escape(content),
  };

  pizzas.push(createdPizza);

  serialize(jsonDbPath, pizzas);

  return createdPizza;
}
```

Nous allons maintenant tester si tout est r√©gl√© au niveau de l'attaque XSS.  
Veuillez vous loguer √† l'aide du compte **admin** (et le password **admin**).  
Veuillez vous rendre sur la page **Add a pizza**.

Comme pr√©c√©demment : 
- Pour le titre de la pizza, vous pouvez ajouter n'importe quoi.
- Dans le contenu de la pizza, veuillez ajouter cela et soumettre : 

``` text
<img src="#" onerror="alert('You have been hacked !')">
```

Maintenant, tout utilisateur connect√© verra simplement appara√Ætre, quand il affiche la **HomePage**, le menu des pizzas avec :

<ScrollableImage name="hacked.png" minWidth="500px" maxWidth="744px" />

Il n'y a plus de code JavaScript malicieux qui peut s'ex√©cuter c√¥t√© client üéâ !

Nous allons maintenant r√©gler les probl√®mes de passwords mis en clair dans un fichier de l'API.

# <InternalPageTitle> S√©curisation des passwords </InternalPageTitle>

Nous souhaitons maintenant assurer que les passwords enregistr√©s dans un support de donn√©es (un fichier ou une base de donn√©es) ne puissent pas √™tre r√©cup√©r√©s.

üëç Pour ce faire, il est recommand√© d'hacher les passwords avant de les enregistrer au niveau d'une API.

Afin de se prot√©ger contre les "hash attacks", on utilise du **salt** :
- un **salt** : c'est une donn√©e al√©atoire qui est utilis√© en entr√©e d'une fonction qui hache des donn√©es. Ainsi, si un hackeur utilise une base de donn√©es de passwords hach√©s, il devra en plus trouver le bon **salt** pour que son attaque puisse fonctionner.
- **salt round** : nombre de fois que l'op√©ration de hachage est faite, rendant les attaques de force brute plus lente et donc difficile ; une valeur de **10** semble √™tre g√©n√©ralement raisonnable et recommend√©e. 

Pour hacher sous Node.js, nous utiliserons la librairie [bcrypt](https://www.npmjs.com/package/bcrypt).

Veuillez installer la librairie **bcrypt** au sein de votre nouveau projet **safe** :
```bash
npm i bcrypt
```

En r√©sum√©, nous allons utiliser :
- la fonction asynchrone **`hash`** de **bcrypt** pour hacher un password ;
- la fonction asynchrone **`compare`** de **bcrypt** pour comparer un password en clair √† un password hach√© ; si le r√©sultat est positif, cela signifie que le password fournit pour un utilisateur correspond au password initial.

Nous pr√©f√©rons utiliser les librairies asynchrone afin de laisser l'API plus disponible √† g√©rer des requ√™tes clientes et pas bloquer celles-ci jusqu'√† la fin d'une op√©ration de **bcrypt**.

Veuillez effacer le fichier **/data/users.json** contenant les credentials d'utilisateurs o√π les passwords ne sont pas hach√©s.

Nous allons maintenant mettre √† jour le mod√®le de "users" pour utiliser **bcrypt**. Veuillez modifier **/models/users.js** :
```js numbered highlighting="2,9,17,21,25-26,42,46,70,73"
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const path = require('node:path');
const { parse, serialize } = require('../utils/json');

const jwtSecret = 'ilovemypizza!';
const lifetimeJwt = 24 * 60 * 60 * 1000; // in ms : 24 * 60 * 60 * 1000 = 24h

const saltRounds = 10;

const jsonDbPath = path.join(__dirname, '/../data/users.json');

const defaultUsers = [
  {
    id: 1,
    username: 'admin',
    password: bcrypt.hashSync('admin', saltRounds),
  },
];

async function login(username, password) {
  const userFound = readOneUserFromUsername(username);
  if (!userFound) return undefined;

  const passwordMatch = await bcrypt.compare(password, userFound.password);
  if (!passwordMatch) return undefined;

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt }, // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

async function register(username, password) {
  const userFound = readOneUserFromUsername(username);
  if (userFound) return undefined;

  await createOneUser(username, password);

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt }, // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function readOneUserFromUsername(username) {
  const users = parse(jsonDbPath, defaultUsers);
  const indexOfUserFound = users.findIndex((user) => user.username === username);
  if (indexOfUserFound < 0) return undefined;

  return users[indexOfUserFound];
}

async function createOneUser(username, password) {
  const users = parse(jsonDbPath, defaultUsers);

  const hashedPassword = await bcrypt.hash(password, saltRounds);

  const createdUser = {
    id: getNextId(),
    username,
    password: hashedPassword,
  };

  users.push(createdUser);

  serialize(jsonDbPath, users);

  return createdUser;
}

function getNextId() {
  const users = parse(jsonDbPath, defaultUsers);
  const lastItemIndex = users?.length !== 0 ? users.length - 1 : undefined;
  if (lastItemIndex === undefined) return 1;
  const lastId = users[lastItemIndex]?.id;
  const nextId = lastId + 1;
  return nextId;
}

module.exports = {
  login,
  register,
  readOneUserFromUsername,
};
```

Voici les modifications apport√©es :
- pour cr√©er un password hash√© : on utilise la fonction asynchrone `hash` pour cr√©er le password hach√©. D√®s lors, `createOneUser` devient asynchrone. De plus, comme `createOneUser` est devenue asynchrone, dans `register`, pour cha√Æner le traitement de cr√©ation du token, on met un **await** √† l'appel de `createOneUser`. Et comme un **await** est ajout√© au sein de `register`, il faut mettre un **async** √† la m√©thode `register`. Attention, du coup, comme `register` est devenue asynchrone, il faudra faire attention √† bien cha√Æner les traitements l√† o√π `register` est appel√©, dans le router **auths**.
- pour v√©rifier qu'un password match √† un password hach√© : on utilise la fonction asynchrone `compare` que l'on cha√Æne √† la cr√©ation du token √† l'aide de **await**. D√®s lors, la fonction `login` doit elle aussi √™tre d√©clar√©e **async**. Attention, du coup, comme `login` est devenue asynchrone, il faudra faire attention √† bien cha√Æner les traitements l√† o√π `login` est appel√©, dans le router **auths**.
- pour cr√©er l'utilisateur **admin** se trouvant dans les **defaultUsers**, on souhaite indiquer comme **password** le password hach√© correspondant au password "admin". Pour se simplifier la vie, on appelle la fonction synchrone `hashSync` (voir ligne 16). Bien √©videmment, dans une application plus robuste, on √©vitera d'hardcoder ce genre de secrets dans les sources de notre application.

Afin de traiter des deux fonctions du mod√®le **users** qui sont devenues asynchrones, `login` et `register`, nous allons modifier le router **/routes/auths** :
```js numbered highlighting="7,13,21,27"
const express = require('express');
const { register, login } = require('../models/users');

const router = express.Router();

/* Register a user */
router.post('/register', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Request

  const authenticatedUser = await register(username, password);

  if (!authenticatedUser) return res.sendStatus(409); // 409 Conflict

  return res.json(authenticatedUser);
});

/* Login a user */
router.post('/login', async (req, res) => {
  const username = req?.body?.username?.length !== 0 ? req.body.username : undefined;
  const password = req?.body?.password?.length !== 0 ? req.body.password : undefined;

  if (!username || !password) return res.sendStatus(400); // 400 Bad Reques

  const authenticatedUser = await login(username, password);

  if (!authenticatedUser) return res.sendStatus(401); // 401 Unauthorized

  return res.json(authenticatedUser);
});

module.exports = router;
```

Nous avons simplement cha√Æn√© les r√©ponses √† faire au client seulement une fois les op√©ration `register` et `login` termin√©es. Pour ce faire, nous avons pr√©c√©d√© le nom de ces m√©thodes par **await**. Nous avons donc du ajouter **async** aux fonctions middleware s'occupant des routes **POST /auths/register** et **POST /auths/login**.

Veuillez v√©rifier que votre application fonctionne correctement.  
Via l'IHM, veuillez faire un register d'un nouvel utilisateur.  
Au niveau de l'API, allez voir le contenu du nouveau fichier **/data/users.json**. Les passwords devraient maintenant √™tre hach√©s, comme par exemple :

```json
[
  {
    "id": 1,
    "username": "admin",
    "password": "$2b$10$RioLKlPFyYFEhv/46gR7dufDkke07eDpWH9tBt/A4Z9tJh0oJnnf2"
  },
  {
    "id": 2,
    "username": "manager",
    "password": "$2b$10$NZZ1zxOPdby6gl4Dw8K0Q.v4ZRWTbh1Ta7qcYzH5G4SrO5z71H0kO"
  }
]
```

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**api-safe**".

En cas de souci, vous pouvez utiliser le code du tutoriel :
- pour le frontend : [jwt-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch).
- pour l'API : [safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

# <InternalPageTitle> Exercice 4.3 : S√©curisation de l'API de myMovies </InternalPageTitle>

A l'exercice pr√©c√©dent (Exercice 7.1), vous avez d√©velopp√© le m√©canisme d'authentification et d'autorisation d'acc√®s √† des op√©rations de votre RESTful API g√©rant des films.

N√©anmoins, cette API n'est pas encore s√©curis√©e. Les passwords sont disponibles en clair dans un fichier JSON et il est possible de faire des attaques XSS.

Commencez par hacker votre site en faisant une injection de Javascript. Ce script "malicieux" affichera un pop-up √† chaque utilisateur affichant la liste des films ; ce pop-up sera suffisamment explicite pour que vos utilisateurs sachent qu'ils ont √©t√© pirat√©s.

Ensuite, veuillez s√©curiser l'API pour √©chapper les caract√®res dangereux et pour hacher les password.

Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :
-	Pour le frontend, il n'y a rien √† d√©velopper, veuillez ex√©cuter  le contenu de votre r√©pertoire d'exercices **/exercises/module7/7.1/hmi**.
-	Pour l'API, utilisez le contenu de votre r√©pertoire d'exercices **/exercises/module7/7.1/api** comme point de d√©part pour cr√©er, dans votre repository local et
votre web repository (normalement appel√© **web2**), le r√©pertoire nomm√©
**/exercises/module7/7.2/api**.

#### ü§ù Tips
Cet exercice est l'application du tutoriel vu dans ce module-ci. N'h√©sitez pas donc √† rejouer les √©tapes vues dans le tutoriel au niveau de votre API : [d) S√©curisation de RESTful API](#d).

‚ö° N'oubliez pas que vos m√©thodes de login et de register deviennent asynchrones, cela impose de bien cha√Æner les traitements dans le router, sinon vous risquez de renvoyer des objets vides en r√©ponses aux requ√™tes.

Veuillez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 7 : safe api**"".

NB : Le code de vos applications se trouve dans votre repository local et
votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√©
**/exercises/module7/7.2/api**.

# <InternalPageTitle> üç¨ Exercice 4.4 : Auto-refresh de myMovies </InternalPageTitle>

S'il vous reste du temps, il serait vraiment int√©ressant de faire en sorte que cycliquement, tous les 5 secondes par exemple, l'affichage de la liste de films se mette automatiquement √† jour.

Ainsi, si d'autres utilisateurs ajoutent un film, vous les verrez directement appara√Ætre dans votre fen√™tre.

‚ö° Attention que si le composant d'affichage des films est utilis√© pour permettre de directement mettre √† jour un film, celui-ci ne doit pas se r√©afficher si un utilisateur est en train de mettre √† jour un film.

#### ü§ù Tips
Pensez √† la fonction **`setInterval`**.

Vous pouvez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 7 : auto-refresh**"".

NB : Le code de vos applications se trouverait dans votre repository local et
votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√©
**/exercises/module7/7.3/hmi**.

# <InternalPageTitle> üç¨ Exercice 4.5 : Gestion de la navigation lors de l'auto-refresh de myMovie </InternalPageTitle>

üí≠ Que peut-il se passer de d√©sagr√©able si un utilisateur passe rapidement de la page listant les informations d'un film vers la page d'ajout d'un film ?

Comme le render de tous les films et une action asynchrone, il est possible que celui-ci soit r√©alis√© apr√®s que l'utilisateur ait quitt√© la page d'affichage des films. Cela peut √™tre g√™nant, car si vous √™tes sur le composant pour ajouter un film, vous ne souhaitez pas que votre formulaire d'ajout d'un film soit remplac√©, de mani√®re erron√©e, par la liste des films !

Nous vous proposons d'impl√©menter ces deux fonctions :
-	Stopper les futurs appels de **fetch**, les appels automatiques vers vos APIs (**setInterval** et **clearInterval**) quand il y a un clic sur un lien ;
-	Stopper les appels de **fetch** en cours vers vos APIs quand il y a un clic sur un lien. En effet, si votre API doit renvoyer beaucoup de donn√©es, notamment quand il y a des images √† communiquer, il est possible que cela prenne plusieurs secondes avant que l'API vous r√©ponde.


#### ü§ù Tips
- Pensez aux fonctions **`setInterval`** et **`clearInterval`**.
- Pour stopper un fetch en cours, vous pouvez utiliser un **AbortControlller**. Toute l'info est disponible sur la [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).

Vous pouvez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 7 : auto-refresh improved**"".

NB : Le code de vos applications se trouverait dans votre repository local et
votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√©
**/exercises/module7/7.4/hmi**.

# <InternalPageTitle> üç¨ Exercice 4.6 : L'essentiel du cours en action </InternalPageTitle>

## Introduction
Voici un exercice qui fait revoir les comp√©tences essentiels de ce cours de JS. Il a √©t√© utilis√© comme examen pour les √©tudiants de Vinci en deuxi√®me ann√©e de bachelier en Informatique de Gestion en ao√ªt 2022. 

Normalement, cette exercice, d√©coup√© en trois questions, devrait se r√©aliser dans un d√©lai de 3h.

Veuillez t√©l√©charger ce fichier
<LinkFile name="examen_js.zip" target="_blank" download>examen_js.zip</LinkFile>.
Cette archive contient un boilerplate pour chaque question et les ressources √† utiliser pour cet examen.

Dans un premier temps, veuillez d√©sarchiver **examen_js.zip** localement sur votre machine.  
‚ö° Veuillez √©viter de le faire sur un r√©pertoire qui est partag√© sur le cloud. En effet, il y a des milliers de fichiers associ√©s aux **node_modules** lorsque vous lancerez l'installation des packages ! Ca serait une vraie horreur √† synchroniser üò® !

## Objectif
Nous allons d√©velopper deux frontends et une API pour une agence de voyages.

## Question 1 : Cr√©er une IHM interactive & moderne
Nous souhaitons afficher des lieux de vacances propos√©s par l'agence de voyages. Il y a 5 lieux diff√©rents, chacun avec un id, un nom et une image.

Le boilerplate pour cette question se trouve dans **/question1**.
Vous trouverez 5 images correspondant √† chaque lieu dans le r√©pertoire **/question1/src/img**, ainsi qu'un fichier contenant une liste des lieux avec leur id, leur nom et leur image dans **/question1/src/utils/places.js**.

Vous devez cr√©er deux pages :
-	La page d'accueil, accessible avec l'URI "/" ou avec un lien nomm√© "Home" dans la barre de navigation, doit afficher une liste de tous les noms de lieux de vacances.
-	La page de photos, accessible avec l'URI "/photos" ou avec un lien nomm√© "Photos" dans la barre de navigation, doit afficher un carrousel des lieux propos√©s.
  - Lorsqu'on arrive sur la page initialement, la page doit afficher le 3√®me lieu dans la liste, avec son image et son nom en dessous.
  - La page doit √©galement afficher deux boutons. Le premier permet d'afficher le lieu pr√©c√©dent dans la liste √† la place de celui-ci. Et  l'autre permet d'afficher le lieu suivant. Ces boutons ne doivent pas √™tre cliquables s'il n'y a plus de lieu suivant ou de lieu pr√©c√©dent dans la liste.

Contraintes d'impl√©mentation : 
-	Veuillez utiliser le fichier **/question1/src/utils/places.js** qui reprend des lieux de vacances. Vous devez mettre √† jour ce fichier pour pouvoir l'utiliser dans votre code JS comme module.
-	Aucune autre page ne doit √™tre disponible sur le site web.
-	Vous devez impl√©menter le carrousel vous-m√™me, vous ne pouvez pas utiliser un carrousel de Bootstrap.
-	Utilisez les images import√©es statiquement dans la liste des lieux de vacances et changez la source de l'image affich√©e quand l'utilisateur clique sur un bouton.

Voici un exemple de ce √† quoi pourrait ressembler votre site web :

<ScrollableImage name="places.png" minWidth="800px" maxWidth="1599x" />

<ScrollableImage name="carousel.png" minWidth="800px" maxWidth="1599x" />

## Question 2 : Cr√©er un service web
Nous souhaitons d√©velopper une RESTful API pour g√©rer les lieux de vacances propos√©s par l'agence, les utilisateurs du site, ainsi que les lieux favoris de ces utilisateurs.

Le boilerplate pour l'API de cette question se trouve dans **/question2**, c'est une copie du boilerplate du cours.

Veuillez cr√©er les op√©rations suivantes :
-	**Cr√©er un nouveau lieu de vacances**. L'op√©ration doit prendre en entr√©e le nom du lieu ainsi que sa description, et doit retourner l'ID du lieu cr√©√© au format JSON. L'op√©ration doit renvoyer une erreur si le nom ou la description ne sont pas fournis.
-	**Cr√©er un nouvel utilisateur**. L'op√©ration doit prendre en entr√©e le nom de l'utilisateur ainsi que son adresse mail, et doit retourner l'ID de l'utilisateur cr√©√© au format JSON. L'op√©ration doit renvoyer une erreur si le nom ou l'adresse mail ne sont pas fournis, ainsi que si un utilisateur existe d√©j√† pour cette adresse mail.
-	**Ajouter un lieu √† ses favoris**. L'op√©ration doit prendre en entr√©e l'ID de l'utilisateur et l'ID du lieu qu'il souhaite ajouter en favori. L'op√©ration doit renvoyer une erreur si aucun utilisateur ne correspond √† l'ID d'utilisateur donn√©, si aucun lieu ne correspond √† l'ID de lieu donn√©, ou si cet utilisateur a d√©j√† ce lieu dans ses favoris.

Vous devez √©galement cr√©er dans le fichier **/question2/RESTClient/tests.http** au minimum une requ√™te par op√©ration que vous devez impl√©menter. Vous pouvez √©galement cr√©er plus de tests si vous le souhaitez.

Contraintes d'impl√©mentation :
-	L'API que vous devez cr√©er doit correspondre aux principes d'une API RESTful.
-	Votre API ne peut pas proposer d'autres op√©rations que celles d√©crites ci-dessus.
-	Les ID que g√©n√®rent votre API doivent provenir du package **uuid**.
-	Les demandes qui sont cr√©√©es doivent persister et donc survivre au red√©marrage de votre application. Vous pouvez faire persister les demandes c√¥t√© serveur de la mani√®re que vous voulez, du moment que cela soit en JSON. N'h√©sitez pas √† utiliser **/question2/utils/json.js**.
-	Aucune autorisation JWT est n√©cessaire.

## Question 3 : Cr√©er une SPA int√©grant une IHM et un web service
Gr√¢ce √† l'API que nous avez d√©velopp√© dans la question 2, l'agence de voyages a pu am√©liorer son API pour proposer un syst√®me de recommandations. Cependant, cette API utilise un syst√®me d'Intelligence Artificielle complexe et les op√©rations qui r√©cup√®rent les recommandations peuvent prendre un certain temps. 

Le boilerplate pour cette question se trouve dans **/question3**.
Vous devez consommer l'API d√©crite ci-dessous et disponible √† l'adresse **https://places-exam-api.azurewebsites.net** pour afficher des recommandations de lieux de vacances. Cette API accepte les requ√™tes venant de toutes les origines et n'a pas de probl√®me de CORS. Vous ne devez donc pas utiliser de proxy pour consommer cette API.

| M√©thode HTTP | URI | Op√©ration | Format |
|---|---|---|---|
| **GET** | **/places**| R√©cup√©rer tous les lieux de vacances | Renvoie : `[ { id, name } ]` |
| **GET** | **/recommended** | R√©cup√©rer le lieu de vacances le plus appr√©ci√© | Renvoie : `{ id, name }` |

Sur la page d'accueil du site web, veuillez afficher le nom de tous les lieux de vacances, renvoy√©s par l'API avec l'URI "/places" (il n'est pas n√©cessaire d'afficher leur ID). 

Toujours sur la page d'accueil, veuillez √©galement afficher le nom du lieu de vacances le plus appr√©ci√©, renvoy√© par l'API avec l'URI "**/recommended**". Comme cette op√©ration peut prendre un certain temps, elle ne peut pas ralentir le chargement de la page. Le reste de la page doit √™tre affich√© avant de consommer cette API, et son r√©sultat doit √™tre rajout√© sur la page quand l'op√©ration est termin√©e.

Aucune autre page ne doit √™tre disponible sur le site web. Pensez donc √† effacer le code du boilerplate qui est inutile.