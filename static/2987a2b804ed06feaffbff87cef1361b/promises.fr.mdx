---
title: "Promesses"
description: "Programmation asynchrone & les promesses"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> l) Programmation asynchrone & les promesses </PathViewerItem>
</PathViewer>

# l) Programmation asynchrone & les promesses

<InternalPageMenu>
  <InternalPageMenuItem> Utilisation de promesses & async / await </InternalPageMenuItem>
  <InternalPageMenuItem> Cr√©ation de fonctions asynchrones renvoyant une promesse </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Utilisation de promesses & async / await </InternalPageTitle>

## Introduction

Plut√¥t que d'utiliser des **.then()** pour cha√Æner des traitements asynchrones, il est possible de simplifier la syntaxe des promesses √† l'aide de **async** et **await**.

On va donc √©crire du code d'une mani√®re √©quivalente √† ce qui serait fait en programmation synchrone.

## async / await & op√©ration asynchrone de lecture de ressources

Nous allons refactorer l'IHM [basic-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch).

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/hmi/async-await** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/hmi/basic-fetch** (ou [routing-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/hmi/async-await**.

Nous allons donc refactorer le code o√π est fait le **fetch**, c'est √† dire **/src/Components/Pages/HomePage.js** (veuillez mettre √† jour tout le code de la fonction arrow associ√©e √† la variable **HomePage**) :

```js numbered highlighting="1,5,9"
const HomePage = async () => {
  try {
    clearPage();

    const response = await fetch('/api/pizzas');

    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

    const pizzas = await response.json();

    renderMenuFromString(pizzas);
    attachOnMouseEventsToGoGreen();
    renderDrinksFromNodes(DRINKS);
  } catch (err) {
    console.error('HomePage::error: ', err);
  }
};
```

Pour tester ce code, il ne faut pas oublier de d√©marrer la RESTful API auparavant : **/web2/tutorials/pizzeria/api/fat-model** ou via le code de ce web repo si vous avez un souci : [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Voici quelques caract√©ristiques importantes de **async** / **await** :

- **await** est utilis√© pour cha√Æner une t√¢che asynchrone (sur une fonction renvoyant une promesse) et ne peut se faire qu'au sein d'une fonction tagu√©e par **async** ; c'est donc le rempla√ßant du **.then(callback)**.  
  ‚ö° Attention, il est donc important qu'au niveau de la fonction arrow, √† la ligne 1 du code donn√© ci-dessus, on indique le **async** !  
  ‚ö° Dans le code donn√© ci-dessus, il est aussi tr√®s important de ne pas oublier les **await**. N'h√©sitez pas √† faire le test en enlevant le **await** de **`const pizzas = await response.json();`**. Que se passe-t-il dans ce cas ? **`response.json()`** √©tant une fonction asynchrone, on passera directement √† la fonction **`renderMenuFromString(pizzas);`** avant m√™me d'avoir r√©cup√©r√© les pizzas de notre RESTful API !
- Toute fonction "tagu√©e" par **async** renvoie automatiquement une promesse ; cela signifie dans le code ci-dessus que la fonction **HomePage** est elle m√™me asynchrone.  
  üí≠ Il est √† parier, et n'h√©sitez pas √† trouver un moyen de vous en rendre compte visuellement, que le footer s'affiche avant le menu !
- On utilise des blocs **try** / **catch** pour g√©rer les erreur ; c'est donc le rempla√ßant du **.catch(callback)**.

## Op√©ration asynchrone d'√©criture d'une ressource

A pr√©sent, nous souhaiterions que notre IHM puisse cr√©er une ressource au sein de la RESTful API. Dans un premier temps, nous allons mettre √† jour le frontend en acceptant que n'importe quel utilisateur puisse cr√©er une pizza et l'ajouter au menu de la pizzeria.  
Bien entendu, cela est temporaire. Nous verrons plus tard comment s√©curiser cette op√©ration, en autorisant un admin seulement √† r√©aliser l'ajout d'une pizza au menu.

Nous allons cr√©er une nouvelle page nomm√©e **AddPizzaPage.js**.
Dans un premier temps, nous allons juste r√©aliser une page statique car il est toujours plus ais√© de d'abord avoir une version visuelle d'une application web, avec la navigation entre les pages, avant de peaufiner chaque page et leurs interactions avec les utilisateurs et les APIS.
Veuillez ajouter ce code dans la nouvelle page **/src/Components/Pages/AddPizzaPage.js**:

```js
import { clearPage, renderPageTitle } from '../../utils/render';

const AddPizzaPage = () => {
  clearPage();
  renderPageTitle('Add a pizza to the menu');
  renderAddPizzaForm();
};

function renderAddPizzaForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const title = document.createElement('input');
  title.type = 'text';
  title.id = 'title';
  title.placeholder = 'title of your pizza';
  title.required = true;
  title.className = 'form-control mb-3';
  const content = document.createElement('input');
  content.type = 'text';
  content.id = 'content';
  content.required = true;
  content.placeholder = 'Content of your pizza';
  content.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Add pizza to the menu';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(title);
  form.appendChild(content);
  form.appendChild(submit);
  main.appendChild(form);
}

export default AddPizzaPage;
```

Nous devons aussi ajouter un √©l√©ment dans la Navbar afin de pouvoir acc√©der √† cette nouvelle page. Pour ce faire, veuillez mettre √† jour **/src/Components/Navbar/Navbar.js** :

```js numbered highlighting="36-38"
// eslint-disable-next-line no-unused-vars
import { Navbar as BootstrapNavbar } from 'bootstrap';

const Navbar = () => {
  renderNavbar();
};

function renderNavbar() {
  const navbar = document.querySelector('#navbarWrapper');
  navbar.innerHTML = `
  <nav class="navbar navbar-expand-lg navbar-light bg-danger">
        <div class="container-fluid">
          <a class="navbar-brand" href="#">e-Pizzeria</a>
          <button
            class="navbar-toggler"
            type="button"
            data-bs-toggle="collapse"
            data-bs-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent"
            aria-expanded="false"
            aria-label="Toggle navigation"
          >
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="#" data-uri="/">Home</a>
              </li>
              <li id="loginItem" class="nav-item">
                <a class="nav-link" href="#" data-uri="/login">Login</a>
              </li>
              <li id="registerItem" class="nav-item">
                <a class="nav-link" href="#" data-uri="/register">Register</a>
              </li>  
              <li class="nav-item">
                <a class="nav-link" href="#" data-uri="/add-pizza">Add a pizza</a>
              </li>           
            </ul>
          </div>
        </div>
      </nav>
  `;
}

export default Navbar;
```

Et finalement, comme le frontend de ce tutoriel utilise le boilerplate du cours, il faut encore configurer le router de l'IHM afin d'indiquer la page √† afficher lorsqu'on clique sur le lien dont **`data-uri`** vaut **add-pizza**. Pour ce faire, veuillez mettre √† jour le fichier **/src/Components/Router/Router.js** pour ajouter ces deux lignes :

```js highlighting="1,10"
import AddPizzaPage from '../Pages/AddPizzaPage';
import HomePage from '../Pages/HomePage';
import LoginPage from '../Pages/LoginPage';
import RegisterPage from '../Pages/RegisterPage';

const routes = {
  '/': HomePage,
  '/login': LoginPage,
  '/register': RegisterPage,
  '/add-pizza': AddPizzaPage,
};
```

A ce stade-ci, votre application **/web2/tutorials/pizzeria/hmi/async-await** devrait √™tre fonctionnelle, vous devriez pouvoir naviguer vers la nouvelle page contenant un formulaire pour ajouter une pizza.

Nous allons maintenant ajouter l'interaction avec l'API au sein de **AddPizzaPage**.
Lorsque nous soumettons le formulaire, nous voulons faire une requ√™te de cr√©ation de pizza √† la RESTful API, c'est donc une requ√™te de type **POST /pizzas** qui doit √™tre l'√©quivalent de ce que nous faisions avec REST Client. Pour rappel, nous faisions une requ√™te de ce genre :

```http
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Ici, c'est le JS √† rajouter dans **AddPizzaPage** qui doit, lors du clic, aller chercher les valeurs des deux champs du formulaire pour cr√©er la repr√©sentation des donn√©es √† cr√©er (**title** et **content**) et faire un **fetch** de l'op√©ration de cr√©ation offerte par l'API.  
Si l'ajout se fait avec succ√®s, on souhaite faire en sorte que l'utilisateur soit redirig√© vers la **HomePage**.

Pour arriver √† nos fins, veuillez ajouter ce code dans la page **/src/Components/Pages/AddPizzaPage.js** :

```js numbered highlighting="34,37-63"
import { clearPage, renderPageTitle } from '../../utils/render';
import Navigate from '../Router/Navigate';

const AddPizzaPage = () => {
  clearPage();
  renderPageTitle('Add a pizza to the menu');
  renderAddPizzaForm();
};

function renderAddPizzaForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const title = document.createElement('input');
  title.type = 'text';
  title.id = 'title';
  title.placeholder = 'title of your pizza';
  title.required = true;
  title.className = 'form-control mb-3';
  const content = document.createElement('input');
  content.type = 'text';
  content.id = 'content';
  content.required = true;
  content.placeholder = 'Content of your pizza';
  content.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Add pizza to the menu';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(title);
  form.appendChild(content);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onAddPizza);
}

async function onAddPizza(e) {
  e.preventDefault();

  const title = document.querySelector('#title').value;
  const content = document.querySelector('#content').value;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      title,
      content,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const response = await fetch('/api/pizzas', options); // fetch return a promise => we wait for the response

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const newPizza = await response.json(); // json() returns a promise => we wait for the data

  console.log('New pizza added : ', newPizza);

  Navigate('/');
}

export default AddPizzaPage;
```

Quelques explications sur ce code, pour les parties d√©j√† connues :

- La gestion d'√©v√©nements n'est pas nouvelle. Ici, on met un √©couteur d'√©v√©nements de type **submit** sur le formulaire. Cela permet d'√©couter tant les clics sur le champs de type **submit** (le bouton) que si l'utilisateur appuie sur **Enter**.  
  üëç On recommande, pour les formulaires, d'utiliser des √©v√©nements de type "submit" plut√¥t que des √©v√©nements de type "click" sur le bouton "submit" afin notamment de prendre en compte si l'utilisateur appuie sur **Enter** pour tenter de soumettre le formulaire.
- L'action par d√©faut d'un formulaire, lors d'un submit, et de faire une requ√™te synchrone vers l'URL du backend indiqu√© dans la propri√©t√© **action** du formulaire, ou sur la m√™me URL que la page en cours si **action** n'est pas donn√©. Pour √©viter un chargement de page non d√©sir√© dans le cadre d'une SPA, on stoppe cette action par d√©faut via **`e.preventDefault()`**.

Pour la nouveaut√© et le **fetch** :

- pour faire une requ√™te de type **POST**, tout comme pour les requ√™tes de type **DELETE**, **PATCH**, **UPDATE**..., il faut l'indiquer √† la m√©thode **fetch**.  
  Cela est indiqu√© dans un objet que nous appelons g√©n√©ralement **options** qui doit contenir la propri√©t√© **method**.
- lorsque l'on doit envoyer des donn√©es dans le **body** d'une requ√™te, alors il faut le faire au sein de la propri√©t√© **body**. Ici, nous souhaitons envoyer un objet content les propri√©t√©s **title** et **content** au format JSON. Nous devons donc utiliser la m√©thode **`JSON.stringify`** qui permet de cr√©er une repr√©sentation JSON d'un objet JS. Notez ici que nous avons √©crit l'objet JS selon une notation simplifi√©e :

```js highlighting="4-7,9-12"
const title = document.querySelector('#title').value;
const content = document.querySelector('#content').value;

{
  title,
  content,
}
// Cet object literal est l'√©quivalent de :
{
  title: title,
  content: content,
}
```

- Il est tr√®s important de sp√©cifier le type de la repr√©sentation de l'objet qui devrait √™tre utilis√© par l'API et qui se trouve dans le body de la requ√™te. Cela est fait via un **header** et la propri√©t√© **Content-Type** (**`'Content-Type': 'application/json',`**).  
‚ö° Si vous oubliez cela, l'API ne pourra pas parser les donn√©es au format JSON vers des objets JS et donc les op√©rations d'√©criture de ressources √©choueront !
- Finalement, si l'op√©ration de cr√©ation de la pizza r√©ussi, nous redirigeons l'utilisateur vers la **HomePage** √† l'aide du composant fonctionnel **`Navigate.js`** offert au sein du fichier **Navigate** dans le dossier **Router** du boilerplate du frontend.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**async-await**".

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
[async-await](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/async-await).

# <InternalPageTitle> Cr√©ation de fonctions asynchrones renvoyant une promesse </InternalPageTitle>

Il est si simple, √† l'aide d'**async** / **await**, de cr√©er des fonctions asynchrones qui renvoient une promesse, qu'il serait dommage de ne pas l'exp√©rimenter.

Imaginons que nous souhaitons cr√©er une fonction asynchrone qui renvoie toutes les pizzas qui sont offertes par l'op√©ration de lecture des pizzas de la RESTful API.

Voici comment nous √©cririons ce code :

```js
async function getAllPizzas() {
  try {
    const response = await fetch('/api/pizzas');

    if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

    const pizzas = await response.json();

    return pizzas;
  } catch (err) {
    console.error('getAllPizzas::error: ', err);
    throw err;
  }
}
```

Cette fonction **getAllPizzas** ne renvoie pas un array de pizzas, mais une **Promise** !  
Si la promesse :
- r√©sout avec succ√®s, alors c'est bien un array de pizzas qui sera renvoy√© par cette fonction.
- √©choue, c'est une exception qui sera renvoy√©e.  
Pour que cela fonctionne, vous devez donc faire en sorte, dans vos fonctions asynchrones, de faire un **throw** d'une erreur en cas d'√©chec du traitement asynchrone.

Comment utiliser ce code au sein de la **HomePage** ?  
Voici comment le code pourrait √™tre mis √† jour pour utiliser la fonction asynchrone **getAllPizzas** au sein de **HomePage.js** :

```js highlighting="1,5"
const HomePage = async () => {
  try {
    clearPage();

    const pizzas = await getAllPizzas();

    renderMenuFromString(pizzas);
    attachOnMouseEventsToGoGreen();
    renderDrinksFromNodes(DRINKS);
  } catch (err) {
    console.error('HomePage::error: ', err);
  }
};
```