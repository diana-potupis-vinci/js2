---
title: "S√©curit√© du browser"
description: "S√©curit√© des communications du browser"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> k) S√©curit√© des communications du browser </PathViewerItem>
</PathViewer>

# k) S√©curit√© des communications du browser

<InternalPageMenu>
  <InternalPageMenuItem> Single Origin Policy & CORS </InternalPageMenuItem>
  <InternalPageMenuItem> Autorisation d'origines & les CORS </InternalPageMenuItem>
  <InternalPageMenuItem> Simulation d'une m√™me origine via un proxy </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.12 : Int√©gration de la RESTful API au sein de l'IHM de myMovies via un proxy </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.13 : Autorisation de nouvelles origines via la RESTful API </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Single Origin Policy & CORS </InternalPageTitle>

La **Single Origin Policy** (**SOP**) sont des r√®gles appliqu√©es par le browser afin :
- de restraindre les interactions entre un document ou script charg√© par une origine avec une ressource d'une autre origine ;
- d'isoler des documents ou scripts malicieux, afin de r√©duire le risque des attaques.

Deux URL ont une m√™me **origine** si ces caract√©ristiques sont les m√™mes :

- **protocole** ;
- **port** ;
- **host** ; l'URL pointe vers le m√™me appareil connect√© √† internet ou √† un r√©seau local

Il est possible de relaxer la s√©curit√© via des **Cross Origin Resource Sharing** (**CORS**).  
**CORS** est un m√©canisme qui utilise des headers HTTP pour indiquer aux browsers qu'ils peuvent autoriser les acc√®s √† des ressources d'origines diff√©rentes.

Cela signifie qu'une application web qui utilise une API ne peut le faire que si les ressources demand√©es √† l'API proviennent d'une m√™me origine, √† moins que la r√©ponse de l'API inclut les bonnes **CORS** (via des header HTTP).

Si l'on autorise trop d'origine, voici un exemple classique d'attaque :

<ScrollableImage name="cors-issue.png" minWidth="500px" maxWidth="700px" />

Imaginez qu'un site d'une banque ne soit pas s√©curis√© avec des techniques modernes. Ce site utiliserait une IHM (`https://my-bank.com`), qui, via un formulaire, permettrait de faire un versement, sous r√©serve d'envoyer un cookie qui contiendrait une variable de session (simple m√©canisme de s√©curit√©) lors d'une requ√™te √† l'API de la banque.

Maintenant, prenons le cas d'un utilisateur qui adore jouer sur le web, un gamer en puissance. Il joue √† un jeu de pinguins, mais soudainement, il est redirig√© vers un site malicieux (`https://malicious.com`), qui lui offre un nouveau jeu avec des dinosaures. Ce site malicieux, en arri√®re plan, pourrait faire une requ√™te vers la m√™me API utilis√©e par `my-bank`.  
Comme c'est le m√™me browser utilis√© par notre gamer, tant pour faire ses virements, que pour jouer, toute requ√™te faite vers `https://api.my-bank.com` enverra d'office les cookies existants et associ√©s au domaine `api.my-bank.com`.
Les r√©sultats peuvent √™tre dramatiques, l'attaquant peut faire des versements jusqu'√† vider le compte de notre pauvre gamer.

Bien s√ªr, gr√¢ce √† la **SOP** appliqu√©e par nos browser, par d√©faut, d√®s que le site malicieux communique avec l'API de la banque, celui-ci bloque l'acc√®s aux ressources de l'API car l'origine du site malicieux est diff√©rente de l'origine de l'API.

Les **CORS** permettent de rel√¢cher la s√©curit√©, afin notamment, dans le sc√©nario √©voqu√©, d'autoriser l'origine `https://my-bank.com` √† acc√©der √† l'origine `https://api.my-bank.com`. En effet, c'est ce que le site de la banque souhaite.  
Par contre, si la banque poss√®de des d√©veloppeurs nuls au niveau s√©curit√© et que ceux-ci autorisent toutes les origines √† interroger l'API, l√†, nous pourrions arriver au hacking d√©crit ci-dessus.

Attention √† ne pas confondre les attaques associ√©es √† une mauvaise gestion des **CORS** aux attaques **XSS**. Les attaques **XSS**, ou **Cross-Site Scripting**, sont un type d'injection de scripts malicieux dans une application web.

Imaginez le forum web de la banque d√©crite pr√©c√©dente et ce sc√©nario :

<ScrollableImage name="xss.png" minWidth="500px" maxWidth="700px" />

L'API de la banque permet d'enregistrer des messages qui sont associ√©s √† des forums sur lesquels leurs clients peuvent poster des messages.  
Si l'API de la banque √©tait mal s√©curis√©e et qu'elle permettait d'enregistrer n'importe quels types d'information en tant que "messages" du forum, il serait possible √† un attaquant d'injecter du JS malicieux dans l'API.  
Plus tard, lors de l'affichage des messages par le forum de la banque (`https://forum.my-bank.com `), le JS malicieux pourra s'ex√©cuter dans le browser de n'importe quel utilisateur, y-compris le gamer d√©crit ci-dessus !
Et vous avez vu que via du JS, on peut envoyer de l'information n'importe o√π, notamment √† l'aide de **fetch**. Ce qui permettrait donc √† notre hacker, via son script malicieux, d'envoyer des cookies contenant des infos sensibles √† son API malicieuse, en vue de futures attaques encore plus malicieuses, comme notamment vider son compte en banque.

La protection contre des attaques XSS se fait √† diff√©rents niveaux. Ca n'est pas l'objet de ce cours, mais nous verrons n√©anmoins, plus tard, certaines techniques pour √©viter les attaques XSS.

Nous allons voir comment nous pouvons communiquer entre un frontend et une API fonctionnant sous deux origines diff√©rentes, √† l'aide de deux techniques diff√©rentes.

# <InternalPageTitle> Autorisation d'origines & les CORS </InternalPageTitle>

A cette partie-ci, nous allons voir comment mettre √† jour une API afin que dans chaque r√©ponse faite √† un client, on ajoute un header permettant d'autoriser une ou plusieurs origines.

Nous allons partir de la derni√®re version de la RESTful de pizzas.

Au sein de votre repo **web2**, veuillez cr√©er le projet nomm√© **/web2/tutorials/pizzeria/api/cors** sur base d'un copi√© coll√© de **/web2/tutorials/pizzeria/api/fat-model** (ou [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/web2/tutorials/pizzeria/api/cors**.

Dans ce projet, veuillez installer le package **cors** :

```bash
npm i cors
```

Nous allons configurer les headers de la RESTful API √† l'aide du middleware **cors** offert par
la librairie **cors**.

Pour configurer et utiliser les **CORS**, veuillez mettre √† jour le fichier **/app.js** :

```js numbered highlighting="4-8,21"
const express = require('express');
const cookieParser = require('cookie-parser');
const logger = require('morgan');
const cors = require('cors');

const corsOptions = {
  origin: 'http://localhost:8080',
};

const usersRouter = require('./routes/users');
const pizzaRouter = require('./routes/pizzas');

const app = express();

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());

app.use('/users', usersRouter);
app.use('/pizzas', cors(corsOptions), pizzaRouter);

module.exports = app;
```

Ici, nous pr√©cisons que l'API doit autoriser l'origine associ√©e au port sur lequel tourne
le serveur de fichiers statiques de Webpack (**8080**). Notons que nous n'avons pas rel√¢ch√© la s√©curit√© pour les ressources de type "users", la fonction middleware **cors** n'est pas appel√©e au niveau du router de pizza.

Veuillez vous assurer que l'API **fat-model** est ferm√©e et veuillez d√©marrer votre nouvelle version de l'API (**api-cors**).

Il vous reste √† vous assurer que votre frontend (**/web2/tutorials/pizzeria/hmi/basic-fetch**) est lui aussi bien d√©marr√© et peut enfin r√©aliser son fetch impl√©ment√© dans **HomePage.js**.

Tout fonctionne correctement ?

Normalement oui, vous devriez avoir le site de la pizzeria qui affiche le menu des pizzas suite √† un appel √† l'API (api-cors).

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**api-cors**".

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :

- pour l'API : [api-cors](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/cors).
- pour le frontend :
  [basic-fetch-no-proxy](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch).

üí≠ OK, √ßa fonctionne bien... Mais cela est possible seulement si nous sommes les propri√©taires de la RESTful API. Maintenant, que faire si une API tierce doit √™tre int√©gr√©e dans notre frontend ?  
Imaginez que vous souhaitez int√©grer une op√©ration d'une API offerte par Google...  
Pensez-vous que vous pouvez leur donner un coup de t√©l√©phone et dire : "Google, peux-tu STP autoriser l'origine associ√©e √† mon site web ?".

Il y a peu de chances...
Nous allons donc voir un autre moyen de contourner la **SOP** (Single Origin Policy) impos√©e par le browser.

# <InternalPageTitle> Simulation d'une m√™me origine via un proxy </InternalPageTitle>

Il est possible de mettre en place un proxy au niveau du frontend afin de faire croire au browser que l'API et le frontend ont la m√™me origine.

Ici, nous sommes dans la situation o√π nous ne souhaitons pas, ou nous n'avons pas les moyens, d'ajouter des origines au niveau de l'API.

Pour le tutoriel, veuillez donc stopper l'ex√©cution de l'API nomm√©e **api-cors**.

Veuillez d√©marrer l'API pr√©c√©dente d√©velopp√©e au module 5 : **/web2/tutorials/pizzeria/api/fat-model** ou via le code de ce web repo si vous avez un souci : [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

Il vous reste aussi √† vous assurer que votre frontend (**/web2/tutorials/pizzeria/hmi/basic-fetch**) est lui aussi bien d√©marr√©. Il devrait toujours y avoir l'erreur associ√©es aux **CORS** donn√©e au sein de la console.

Nous allons mettre en place un m√©canisme au niveau du frontend pour faire passer toutes les requ√™tes √† destination de l'API par un proxy ; le proxy aura la m√™me origine que le serveur de fichiers statiques ayant offert le frontend.

Voici le workflow que nous allons appliquer √† notre site g√©rant la pizzeria :

<ScrollableImage name="proxy.png" minWidth="691px" maxWidth="691px" />
<figcaption>Redirections des requ√™tes via un proxy</figcaption>

Gr√¢ce √† ce diagramme, on voit comment mettre √† jour le tutoriel pr√©c√©dent qui affichait une erreur au niveau des **CORS** : on va faire une requ√™te GET vers **/api/pizzas** et non plus vers **http://localhost:3000/pizzas**.

Pour cela, nous avons besoin d'un proxy. Et bien √ßa tombe bien, le serveur de d√©veloppement de Webpack met √† disposition un proxy. Celui-ci est d'ailleurs configur√© ainsi dans le boilerplate (voir fichier **./webpack.config.js**) :

```js
proxy: {
      '/api': {
        target: 'http://localhost:3000',
        pathRewrite: { '^/api': '' },
      },
    },
```

Cela signifie qu'√† chaque fois qu'une requ√™te sera faite sur **/api** (on reste sur la m√™me origine que le serveur de fichiers statiques, **8080** tel que configur√© dans **./webpack.config.js** du boilerplate), celle-ci sera redirig√©e vers le port **3000**, le port de l'API.
Le **pathRewrite** permet de ne pas reprendre **/api** dans l'URL de la redirection :
**GET /api/pizzas** devient **GET http://localhost:3000/pizzas**.

Dans le code du tutoriel en cours (**basic-fetch**), veuillez mettre √† jour l'URL au niveau du **fetch** dans **HomePage.js** :

```js numbered highlighting="4"
const HomePage = () => {
  clearPage();

  fetch('/api/pizzas')
    .then((response) => {
      if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);
      return response.json();
    })
    .then((pizzas) => {
      renderMenuFromString(pizzas);
      attachOnMouseEventsToGoGreen();
      renderDrinksFromNodes(DRINKS);
    })
    .catch((err) => {
      console.error('HomePage::error: ', err);
    });
};
```

N'oubliez pas que votre API (**fat-model**) doit √™tre ex√©cut√©e, tout comme votre frontend (**basic-fetch**).

A ce stade-ci, l√† aussi, tout devrait fonctionner, le menu des pizzas est affich√© suite √† l'appel √† notre RESTful API ne relaxant pas la s√©curit√© !

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**hmi-proxy**".

En cas de souci, vous pouvez utiliser le code du tutoriel :

- pour le frontend : [basic-fetch](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch).
- pour l'API : [fat-model](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/fat-model).

üç¨ Voici quelques infos non capitales pour ce cours-ci :

- Il existe une multitude de proxy pour un environnement de d√©veloppement : **Webpack devServer** et son proxy, **VS Code proxy**, proxy l√©ger de **Node** directement configurable via **package.json** (`"proxy": "http://localhost:3000",`), ...
- Il existe par exemple un proxy complet sous Node : **http-proxy-middleware**.
- Pour la production, lorsque vous d√©ployer une application web sur le cloud, il faudra trouver les instructions de votre provider pour voir comment configurer le proxy.  
  Par exemple, pour configurer un **static file server** et son **proxy** sous **heroku** (provider de services d'h√©bergements sur le cloud), il faut configurer le fichier **/static.json**.

üí≠ Que pensez-vous du code associ√© aux t√¢ches asynchrones, afin de cha√Æner des actions suite au **fetch** ?  
Ca n'est pas des plus lisibles... imaginez que vous avez des tonnes de **.then()**, dans lesquels vous allez aussi faire appel √† des fonctions asynchrones... Ca deviendra vite compliqu√© comme code.

Nous allons donc voir comment rendre la programmation asynchrone plus l√©g√®re, √† l'aide de promesses et de **async** / **await**.

# <InternalPageTitle> Exercice 2.12 : Int√©gration de la RESTful API au sein de l'IHM de myMovies via un proxy </InternalPageTitle>

Vous allez int√©grer le frontend de **myMovies** r√©alis√© au module 3 (Exercice 3.1) avec la RESTful API d√©velopp√©e au module 5 (Exercice 5.2).

L'application **myMovies** doit permettre ces nouveaux cas d'utilisation (ou use cases):
-	UC1 : l'affichage, sous forme de tableau, de toutes les ressources de type films.
-	UC2 : l'ajout d'une ressource de type films via un formulaire d'ajout d'un film.
- UC3 : la suppression d'un film.
- UC4 : la mise √† jour des donn√©es d'un film (√† l'exception de l'id associ√© √† un film).

Nous acceptons, √† ce stade-ci, que des utilisateurs anonymes puissent r√©aliser des op√©rations qui normalement devraient √™tre s√©curis√©es. Nous verrons au module prochain comment authentifier et autoriser des utilisateurs afin de prot√©ger l'acc√®s aux op√©rations d'API.

Afin de r√©aliser cet exercice, voici les contraintes d'impl√©mentation :
-	Ex√©cutez votre API se trouvant dans **/exercises/module5/5.2**.
-	Utilisez le contenu de votre r√©pertoire d'exercices **/exercises/module3/myMovies** comme point de d√©part pour cr√©er,dans votre repository local et
votre web repository (normalement appel√© **web2**), le r√©pertoire nomm√©
**/exercises/module6/6.2**.
-	Veuillez utiliser le proxy de votre frontend afin de contourner les probl√®mes associ√© √† la gestion des CORS.
- Veuillez d√©velopper de mani√®re incr√©mentale votre IHM, use case par use case, en v√©rifiant le bon fonctionnement de chaque cas d'utilisation avant de passer au d√©veloppement de l'UC suivant (=> d√©velopper UC1, puis UC2, puis UC3, puis UC4).

#### ü§ù Tips
Cet exercice de consommation d'une API consiste simplement en la mise-√†-jour du frontend **myMovies** r√©alis√© au module 3 (Exercice 3.1) : vous devriez cr√©er de nouvelles pages et ajouter des op√©rations de type **fetch** vers votre RESTful API d√©velopp√©e au module 5 (Exercice 5.2). Il n'y a normalement rien √† faire au niveau de la RESTFul API, si ce n'est de l'ex√©cuter.

‚ö° Lors de l'ajout d'un film, n'oubliez pas que le budget et la dur√©e doivent √™tre des nombres, pas des strings !

Comment g√©rer l'UC de suppression d'un film ?
- Vous pourriez avoir un bouton **Delete** pour chaque ligne du tableau affichant les films. Lors du clic sur un bouton **Delete**, vous feriez une requ√™te de type **DELETE** vers la RESTful API. Attention, pour une requ√™te de type **DELETE**, l'identifiant de l'objet √† supprimer doit √™tre donn√©e dans l'URL associ√©e au **fetch**.
- Comment retrouver l'identifiant du film affich√© dans le tableau ? 
  Pensez au **data-attribute**, vous pouvez cacher de l'information dans l'HTML. Par exemple, chaque bouton **Delete** pourrait contenir un **data-attribute** √©tant l'id du film. Il est aussi possible d'utiliser la propri√©t√© **id** du bouton.

Comment g√©rer la mise √† jour des donn√©es d'un film ?
  - Option 1 (la plus cool √† d√©couvrir üòâ) : Vous pourriez faire en sorte que l'HTML du tableau affichant les films, lors d'un clic, devienne √©ditable. Pour cette option :
    - Voici, √† quoi pourrait ressembler votre application √† la fin de l'exercice. Vous avez bien s√ªr la libert√© de faire quelque chose de totalement diff√©rent visuellement !
    <ScrollableImage name="movies.png" minWidth="700px" maxWidth="1268px" />
    - Veuillez noter que contrairement au frontend pr√©c√©dent r√©alis√©e √† l'Exercice 3.1, l'info **title** et **link** ne sont plus int√©gr√©es dans une m√™me colonne, via des hyperlinks ; avec l'option 1, nous devrions consid√©rer deux colonnes, une pour le titre et l'autre pour le lien.
    - Vous pouvez utiliser la propri√©t√© HTML **contenteditable="true"** pour rendre les cellules du tableau √©ditables. Voici un exemple pour rendre une cellule associ√©e au titre √©ditable :
    ```js highlighting="1"
    <td class="fw-bold text-info" contenteditable="true">${
                element.title
    }</td>
    ``` 
    - Pour acc√©der aux cellules qui se trouvent dans une m√™me ligne que vous mettez √† jour, vous pouvez utiliser la DOM API de votre browser :
      - on obtient le parent d'un √©l√©ment HTML via l'attribut **parentElement** ; par exemple, si vous avez un √©couteur d'√©v√©nements de clics sur un bouton **Save**, ce bouton se trouvant au sein d'une **td** qui se trouve elle-m√™me au sein d'une **tr** : **`e.target.parentElement.parentElement`**  donne acc√®s √† la **tr** associ√©e au bouton **Save** sur lequel on a cliqu√©.
      - on acc√®de aux enfants d'un √©l√©ment HTML via l'attribut **children** ; par exemple, **`tr.children[0]`** donne acc√®s √† la premi√®re **td** au sein de **tr**.
    - Vous pourriez avoir un bouton **Save** pour chaque ligne du tableau affichant un film. Lors d'un clic sur un bouton **Save**, vous faites appel √† l'API en faisant la requ√™te de mettre √† jour toutes les propri√©t√©s du film, m√™me celle n'ayant pas de nouvelles valeurs.
    - Attention, pour une requ√™te de type **PUT** (mise √† jour de toutes les propri√©t√©s d'une ressource) ou de type **PATCH** (mise √† jour partielle d'une ressource), vous devez indiquer l'id dans l'URL du **fetch**, et la repr√©sentation de donn√©es √† mettre √† jour doit se trouver dans le body de la requ√™te (ce sont les conventions REST que nous avons fix√©es dans le cadre de ce cours).
    -	Si vous aviez besoin de r√©aliser une action en cas de changement du contenu d'une cellule dont **contenteditable** est activ√©, vous pouvez g√©rer le type d'√©v√©nement **input**.
  
  <br/>

  - Option 2 : il est aussi possible de cr√©er un nouveau composant Javascript (une page, une modal ou autre) qui reprendrait un formulaire dont les inputs contiendraient d√©j√† les valeurs existantes des propri√©t√©s d'un film. 

Veuillez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 6 : full integration with RESTful API**"".

NB : Le code de votre application web se trouve dans votre repository local et
votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√©
**/exercises/module6/6.2**.

# <InternalPageTitle> Exercice 2.13 : Autorisation de nouvelles origines via la RESTful API </InternalPageTitle>

S'il vous reste du temps, n'h√©sitez pas √† mettre √† jour l'API se trouvant dans **/exercises/module5/5.2** afin d'autoriser toutes les origines locales : faites en sorte que tous les ports soient autoris√©s !

Veuillez ensuite cr√©er une copie de votre frontend d√©velopp√© √† l'exercice pr√©c√©dent (Exercice 6.1) et le mettre √† jour pour ne plus utiliser le proxy du frontend. Vous consommez directement l'API en indiquant son URL compl√®te, y compris le port. Par exemple, pour lire les pizzas du menu, vous faites un fetch √† l'URL : `http://localhost:300/pizzas`.

Une fois l'API mise √† jour, veuillez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 6 : cors**"".

Le code de votre API se trouve dans votre repository local et
votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√©
**/exercises/module6/6.3/api-cors**.

Une fois le frontend mis √† jour, veuillez faire un **commit** de votre code avec le message suivant : 
"**myMovies : module 6 : integration with RESTful API without proxy**"".

Le code de votre application web se trouve dans votre repository local et
votre web repository (normalement appel√© **web2**) dans le r√©pertoire nomm√©
**/exercises/module6/6.3/hmi-no-proxy**.